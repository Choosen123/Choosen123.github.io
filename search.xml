<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cpp-basic</title>
    <url>/2025/Cpp-basic/</url>
    <content><![CDATA[static
静态方法不能引用非静态变量
非静态成员变量是对象的一部分，每个对象的非静态成员变量都有独立的存储空间。而静态成员函数属于类，与具体的对象无关。
//每个非静态方法总是获得当前类的一个实例做参数
枚举enum
enum name : unsigned char   //指定类型 &#123;A=2,B=4,C=7      //&#125;name c = A;
构造函数——每次构造类实例时，自动执行的函数
class Entity&#123;    public:    float X,Y;Entity()&#123;&#125;Entity(float x,float y)&#123;      //带参数的构造函数，使用时构造带参实例    Entity e(1.0,2.3)    X=x;    Y=y;&#125;&#125;
存在一个默认构造函数，但啥也没干
Log类默认构造函数被删除（delete），因此无法构造实例
初始化列表是C++中用于在构造函数中初始化类成员变量的一种语法结构。它提供了一种高效且简洁的方式来初始化成员变量，尤其是在处理类的继承和资源管理时非常有用。下面将详细介绍初始化列表的语法、用途和一些最佳实践。
初始化列表的语法初始化列表位于构造函数的参数列表之后，使用冒号：分隔，后面跟着一个用逗号分隔的成员变量初始化列表。基本语法如下：
ClassName(ConstructorParameters) : Member1(Initializer1), Member2(Initializer2), ... &#123;    // 构造函数体&#125;class Player &#123;public:    // 构造函数    Player(const std::string&amp; name, int age) : m_Name(name), m_Age(age) &#123;        // 构造函数体可以为空，因为所有初始化工作都在初始化列表中完成了    &#125;    // 成员函数    void DisplayInfo() const &#123;        std::cout &lt;&lt; &quot;Player Name: &quot; &lt;&lt; m_Name &lt;&lt; &quot;, Age: &quot; &lt;&lt; m_Age &lt;&lt; std::endl;    &#125;private:    std::string m_Name;  // 成员变量    int m_Age;           // 成员变量&#125;;
使用初始化列表可避免创建两个实例
析构函数——实例删除时执行
~Entity(){
}
继承——子类包含父类的所有

public
：公有继承。基类的公有成员和保护成员在派生类中仍然是公有成员和保护成员，可以被派生类的成员函数以及派生类对象直接访问。
protected
：保护继承。基类的公有成员和保护成员在派生类中成为保护成员，可以被派生类的成员函数访问，但不能被派生类对象直接访问。
private
：私有继承。基类的公有成员和保护成员在派生类中成为私有成员，只能被派生类的成员函数访问，派生类对象和其他函数都无法直接访问。

Entity* e = new Entity();
使用new运算符在堆（heap）上创建了一个Entity类的实例，并将该实例的地址赋值给指针变量e

new是C++中的一个运算符，用于在堆上动态分配内存并构造对象。
使用 new 分配的内存必须使用 delete 释放，否则会导致内存泄漏
ClassName* pointer = new ClassName(parameters);
虚函数

输出：全为Entity类的GetName
C++会在Entity内部找GetName()而不是用户希望的Player内部
解决：基类中加上virtual，子类中加override
纯虚函数——virtual … = 0;
具有纯虚函数的类无法实例，其子类也必须在自身或者更上级实现纯虚函数覆写之后才能实例。
可以定义一个基类，内部写入纯虚函数，其子类可以各自覆写，然后将抽象基类作为参数（如指针）放入一个通用的函数中
子类必须实现，否则无法实例化
C++可见性：
private：只有类自身和友元可以访问，子类也不行
protected：类自身，子类，外部不可见
public：都可以
std::string
cout 字符串要包括 
双引号内是const char 数组
std::string name = std ::string(“Cherno”) + “hello!”;
name.find(“”)
字符串作为函数参数输入，尽量const std::string &amp; string，避免复制
字符串字面量
char* name = “Cherno”;
const cahr* name = “Cherno”
储存在const区，修改是未定义的
wchar_t—L char16_t—u char32_t—U
类中的const
不能改变类中变量值，只能读取
变量加上前缀mutable 可以改动
实例调用含const修饰的函数，本身必须也要用const修饰
创建对象
1.在栈上创建 能用这个就用这个
2.在堆上 特殊情况，特殊要求     使用new    必须手动释放
argv[0] 是程序的名称，
argv[1] 到 argv[argc-1] 包含传递给程序的其他参数。
基于范围的 for 循环（Range-based for loop）是一种简化遍历容器（如数组、向量、列表等）的语法
for (元素类型 元素变量 : 容器) {
// 使用元素变量
}
for(rclcpp::Parameter n : params){
RCLCPP_INFO(this-&gt;get_logger(),“key = %s , value = %s”,n.get_name().c_str(),n.value_to_string().c_str());
//判断是否含有
  RCLCPP_INFO(this-&gt;get_logger(),&quot;是否包含%s? %d&quot;,n.get_name().c_str(),this-&gt;has_parameter(n.get_name()));

&#125;

std::to_string: 数字等转换成字符串
cin.getline() :接收一个字符串，可以接收空格并输出
1、cin.getline()实际上有三个参数，cin.getline(接收字符串的变量,接收字符个数,结束字符)
2、当第三个参数省略时，系统默认为’\0’
3、如果将例子中cin.getline()改为cin.getline(m,5,‘a’);当输入jlkjkljkl时输出jklj，输入jkaljkljkl时，输出jk
#include 
using namespace std;
main ()
{
char m[20];
cin.getline(m,5);
cout&lt;&lt;m&lt;&lt;endl;
}
getline():接收一个字符串，可以接收空格并输出，需包含“#include”
#include
#include
using namespace std;
main ()
{
string str;
getline(cin,str);
cout&lt;&lt;str&lt;&lt;endl;
}
]]></content>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Semaphore-and-Mutex</title>
    <url>/2025/Semaphore-and-Mutex/</url>
    <content><![CDATA[数据的同步机制
数据的同步是指，如何能通知任务新数据的到来并同时提高CPU的利用率。
假设一个简单的生产者消费者模型–有两个任务，一个任务是数据的生产者（Producer）任务，一个任务是数据的消费者（Consumer）任务，消费者任务等待生产者任务产生的数据并进行处理。按照正常的思路，消费者任务和生产者任务会轮流执行，但是如果在消费者任务执行的时候数据还没有产生的话，消费者任务的运行就是无用的，会降低CPU的使用效率。
为此，FreeRTOS引入了信号量（Semaphore）概念，通过信号量的同步机制可以使消费者任务在数据还没到达的时候进入阻塞状态，并让出CPU资源给其他任务。信号量是一种同步机制，可以起到消息通知和提高CPU利用率的作用。
对于信号量的操作有两种，获取信号量（taking a semaphore）和给予信号量（giving a semaphore）。在生产者消费者模型中，生产者生产数据后给予信号量，消费者获取信号量后可以处理数据
信号量

二进制信号量
信号量数目最多为1,最多只能通知解锁一个任务。
计数信号量
信号量数目为多个，可以通知解锁多个任务。


常见API

创建二进制信号量

SemaphoreHandle_t xSemaphoreCreateBinary( void )

创建成功返回信号量句柄，失败返回NULL


获取信号量

BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait )

xSemaphore: 信号量句柄
xTicksToWait：如果信号量不可用时任务处于阻塞态的最长时间。portMAX_DELAY一直等待。
成功返回pdPASS,失败返回pdFALSE


给予信号量

BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore )

xSemaphore：信号量句柄
成功返回pdPASS,失败返回pdFALSE

中断版本
BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore,BaseType_t *pxHigherPriorityTaskWoken )

创建计数信号量

SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount,UBaseType_t uxInitialCount );

uxMaxCount：计数信号量包含信号量的最大值
uxInitialCount：计数信号量中信号量的初始值

信号量应用
#全局变量共享SemaphoreHandle_t xBinarySemaphore；int main(void)&#123;    ...    xBinarySemaphore = xSemaphoreCreateBinary();    ...&#125;void Task_Producer(void const * argument)&#123;    //生产者任务负责生产数据并给予信号量    for( ;; )    &#123;        ...        if(true==produce_some_data())        &#123;           xSemaphoreGive(xBinarySemaphore);        &#125;        ...    &#125; &#125;void Task_Consumer(void const * argument)&#123;    //消费者任务等待获取信号量并进行数据处理    for( ;; )    &#123;        xSemaphoreTake( xBinarySemaphore, portMAX_DELAY );        //下面是对数据的处理函数        ...       &#125;    &#125;
二进制信号量适用于在数据产生的频率比较低的场合。如果数据产生的频率较高，因为信号量最多只能保存一个信号，更多产生的数据将会直接被忽略抛弃。此时需要使用计数信号量（counting semaphore）。
当有多个生产任务时，单纯依赖信号量，无法区分是谁生产的资源。可以使用队列传递资源信息。
信号量的资源保护作用

在上图中，有个低优先级的任务（LP）和高优先级的任务（HP），两个任务都可以对一个资源进行操作。为了对资源进行保护采用了信号量的机制。LP首先获得信号量可以对资源进行操作，在时刻1，HP因为优先级高在内核调度中抢占了LP，在时刻2，HP想获得信号量但失败因此进入了阻塞状态。之后LP可以继续对资源操作，在时刻3执行完毕后归还了信号量。在时刻4，HP因为优先级高在内核调度中抢占了LP并获取了信号量可以对资源可以操作。
优先级倒置
采用信号量保护资源的话会有个弊端，有时会产生一种现象叫做优先级倒置（Priority inversion ）。

改善-互斥量
互斥量是二进制信号量的变种，需在FreeRTOSConfig.h设置configUSE_MUTEXES为1。用于确保同一时间只有一个任务能访问共享资源，防止多任务并发访问导致的数据不一致问题。



特性
互斥量
信号量




所有权
只有获取锁的任务可以释放
任何任务都可以释放


优先级继承
支持
不支持


递归性
支持递归锁
不支持


用途
资源保护
同步和资源计数



递归锁:允许同一任务多次获取同一互斥量，避免自死锁
优先级继承：持有互斥量的低优先级任务临时继承等待该互斥量的最高优先级任务的优先级
相关API
创建互斥量:
SemaphoreHandle_t xSemaphoreCreateMutex( void )
使用
// 首先申明个互斥量的全局变量SemaphoreHandle_t xMutex；int main(void)&#123;    ...    xMutex = xSemaphoreCreateMutex();    ...&#125;void Function_Resource(void const * argument)&#123;    //要保护的资源函数    ...    xSemaphoreTake( xMutex, portMAX_DELAY );    &#123;      //对资源的处理      ...    &#125;    xSemaphoreGive( xMutex );        ...        &#125;
关键区
关键区（Critical Section）是资源保护的另一种方法。在FreeRTOS有两个宏定义，分别是taskENTER_CRITICAL()和taskEXIT_CRITICAL()。
taskENTER_CRITICAL()；...taskEXIT_CRITICAL();
taskENTER_CRITICAL()宏定义会关闭所有中断包括内核切换所在的中断，taskEXIT_CRITICAL()宏定义会再次打开中断。所以处于宏定义之间的代码可以被独占地执行，这是保护资源的一种比较暴力的方式。
]]></content>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>can-bus</title>
    <url>/2025/can-bus/</url>
    <content><![CDATA[结构

闭环（高速CAN）


CAN总线网络由ISO 11898标准定义，是高速、短距离的CAN网络，通信速率为125kbit/s到1Mbit/s。在1Mbit/s通讯速率时，总线长度最长达40m。

开环（低速CAN）


两根信号线独立，各自串联一个2.2k欧的电阻。这种CAN总线网络由ISO11519-2标准定义，是低速、远距离的CAN网络，通信速率最高125kbit/s。在40kbit/s速率时，总线最长距离可达1000m。
基本
CAN总线有两条信号线，CANH和CANL,没有时钟同步信号线，是一种半双工异步通信，类似于UART。两根信号线通常使用双绞线，传输差分信号（有效抑制外部电磁干扰）。
下面只讨论高速CAN。
以CANH和CANL间的电压差代表总线电平，与逻辑信号1或0对应。

隐性电平(Recessive)对应于逻辑1
显性电平(Dominant)对应于逻辑0

高速CAN中隐性电平在电压差0附近，显性电平主要在电压差2V附近。

在高速和低速CAN中,从隐性信号向显性信号过渡的速度更快，因为此时CAN线缆被主动积极地驱动。显性向隐性的过渡速度主要取决于CAN网络的长度和导线的电容。
CAN总线采用不归零码位填充技术（NRZ），发送器只要检测到位流里有5个连续相同值的位，便自动在位流里插入补充位。(后续说明)
CAN总线上的一个终端设备称为一个节点(Node)，没有主设备从设备的区别。一个CAN节点的硬件部分一般由两部分组成：

CAN控制器：实现CAN协议逻辑层功能，构建符合CAN协议的数据帧等，仲裁等等。
CAN收发器：实现MCU逻辑电平与物理CAN总线电平之间的转换。
例如发送数据流程：

微控制器将数据传送给CAN控制器
CAN控制器构建符合协议的数据帧
CAN控制器将逻辑电平信号发送给收发器
收发器将逻辑信号转换为CAN总线差分信号



仲裁机制： CAN总线采用非破坏性仲裁机制，通过比较消息标识符的优先级来决定哪个节点有权继续发送数据。这种机制确保了总线上数据传输的有序性，避免了冲突。
广播通信： CAN总线采用广播通信方式，即发送的数据帧可以被总线上的所有节点接收。这种特性有助于信息的共享和同步，同时减少了系统的复杂性。
CAN位时序和波特率
一个CAN网络需要规定一个通信的波特率，各节点都以相同的波特率进行数据通信。
为了实现位同步，CAN 协议把每一个数据位的时序分解成如图所示的SS 段、PTS 段、PBS1 段、PBS2段，这四段的长度加起来即为一个CAN数据位的长度。分解后最小的时间单位是Tq(time quantum，时间量子)，而一个完整的位由8~25个Tq组成。
Tq：tq由CAN控制器的时钟频率fcan决定。在STM32F407中，两个CAN控制器在APB1总线上，CAN控制器有预分频器，APB1总线的时钟信号PCLK1经分频后得到fcan。

(总线电平并没有在一个位时序内发生数次电平变化！！！图有误导性)

发送节点产生跳变沿的物理过程

总线空闲状态：当总线空闲时，所有节点都不驱动总线，总线处于隐性状态(高电平，逻辑1)。
CAN使用差分信号，空闲时CAN_H与CAN_L之间的电位差约为0V
发送开始：
当控制器准备发送时，首先发送SOF(起始帧)位，这是一个显性位(低电平，逻辑0)。
发送节点通过驱动其收发器输出级，使CAN_H线变为约3.5V，CAN_L线变为约1.5V，这产生了约2V的电位差，代表显性位(0)
关键跳变沿：从空闲(隐性,1)到SOF(显性,0)的转变产生了一个从高到低的跳变沿,这个下降沿是CAN帧传输开始的标志，也是所有接收节点开始同步的触发点


该图中表示的CAN通讯信号每一个数据位的长度为19Tq，其中SS段占1Tq，PTS段占6Tq，PBS1段占5Tq，PBS2段占7Tq。信号的采样点位于PBS1段与PBS2段之间，通过控制各段的长度，可以对采样点的位置进行偏移，以便准确地采样。


SS段(SYNC SEG)同步段
若通讯节点检测到总线上信号的跳变沿被包含在 SS 段的范围之内，则表示节点与总线的时序是同步的，当节点与总线同步时，采样点采集到的总线电平即可被确定为该位的电平。SS 段的大小固定为 1Tq。


PTS段(PROP SEG)传播时间段
用于补偿网络的物理延时时间。是总线上输入比较器延时和输出驱动器延时总和的两倍。PTS 段的大小可以为 1~8Tq。
如果没有PTS段，当发送节点刚开始发送位的时候，远端接收节点还没有收到信号，可能会错过重要的边沿信息，导致同步失败。


PBS1段(PHASE SEG1)相位缓冲段
用来补偿边沿阶段的误差，它的时间长度在重新同步的时候可以加长。PBS1 段的初始大小可以为 1~8Tq。


PBS2段(PHASE SEG2)相位缓冲段
用来补偿边沿阶段误差的，它的时间长度在重新同步时可以缩短。PBS2 段的初始大小可以为 2~8Tq。



当节点检测到边沿不在预期的SS段时，启动再同步:
如果边沿提前到来，PBS2段会被缩短,
如果边沿延后到来，PBS1段会被延长,
调整量受SJW(同步跳跃宽度)限制


SJW(resynchronization Jump Width)再同步跳转宽度
决定了相位缓冲段加长或缩短的上限，通常为1～4个tq。


如果检测到边沿在SS段后3Tq出现,受SJW(2Tq)限制，只能延长PBS1段2Tq，仍存在偏差，怎么办？
CAN不试图在单次重新同步中完全纠正所有偏差，而是通过多个位的连续重新同步来逐渐达到更好的同步状态，随后的位传输中会继续执行重新同步，逐步减小累积偏差。
采样点通常设置在位时间的70%-80%处,即使有1Tq的残余偏差，采样点仍能落在信号稳定区域。只要残余偏差不导致采样点跨越位边界，通信仍然可靠

通过位时序的控制，CAN总线可以进行位同步，以吸收节点时钟差异产生的波特率误差，保证接收数据的准确性。
波特率：总线上的各个通讯节点只要约定好 1 个 Tq 的时间长度以及每一个数据位占据多少个 Tq，就可以确定 CAN 通讯的波特率。

虽然严格来说同步调整确实会暂时改变位时长（影响瞬时波特率），但系统的整体通信速率仍由配置的波特率决定。

同步方法
硬同步
硬同步是接收单元在总线空闲状态检测出帧起始时进行的同步调整。硬同步仅在消息帧的开头（SOF位）执行。 在空闲时段（帧间间隔（INTERFRAME SPACING）中的总线空闲）之后，网络上的每个CAN控制器都会在SYNC_SEG的第一个接收隐性到显性边沿时初始化其当前位周期时序。 随后在每个接收到的隐性到显性边沿的整个消息的剩余部分中执行一次重新同步。
硬同步调整宽度不限。经过硬同步后，无论边沿相位误差如何，位时序都会在 Sync_Seg 结束时重新启动。因此，硬同步迫使硬同步的边沿位于重新启动的位时间的同步段内。


根据 CAN 规范，当总线空闲时总线为隐性电平。此时，节点 A 发送数据，在出现 SOF 时，总线上的其他节点（如节点 B）也会监控到该变化。但是，节点 B 会发现，自己当前位的 SS 段和发送节点 SOF 位的 SS 段不同步。此时，节点 B 将强制将自己 SOF 位的 SS 段拉到与节点 A 的 SOF 位的 SS 段同步。

重新同步
在接收过程中检测出总线上的电平变化时进行的同步调整。 每当检测出1-&gt;0边沿时，根据 SJW 值通过加长 PBS1 段，或缩短 PBS2 段，以调整同步。但如果发生了超出 SJW 值的误差时，最大调整量不能超过 SJW 值。


只用隐性→显性（1→0）这类边沿做同步锚点
同一个位内至多做一次重新同步（硬件会忽略该位里的后续边沿，以免过度调整）

避免长时间没有同步锚点，can采用位填充规则

为什么会在“同一个位”（以接收端本地时钟划的位窗口）里看到边沿:

发射端与接收端的位边界不完全对齐:
真正的电平翻转都发生在发射端的位边界上，但由于两端时钟误差与总线传播延时，这个翻转到达接收端时，可能落在接收端当前位的 PTS/PBS1/PBS2 内，而不是它期望的 SS 段里。从接收端视角，这就是“位内部出现了一个 1→0 边沿”，因此需要在“当前位内”做一次重新同步去追齐它。
物理层非理想导致“多次过阈” :
反射/震荡：终端不匹配、支路过长、走线不当会引起振铃，差分电压在阈值附近来回晃，比较器可能先后多次从隐性判到显性、又回去。
EMI/噪声脉冲：外部干扰或地弹跳让总线瞬时叠加毛刺，短暂越过比较阈值，形成伪边沿。
缓慢边沿+噪声：上升/下降沿过慢时，叠加噪声更容易造成阈值抖动，出现“抖边”。


]]></content>
      <tags>
        <tag>CAN总线通信</tag>
      </tags>
  </entry>
  <entry>
    <title>heap-and-stack</title>
    <url>/2025/heap-and-stack/</url>
    <content><![CDATA[freertos堆栈

注意堆栈空间分配方向相反，若两区域相互覆盖会出现无法预料的问题。
任务如何分配空间

当调用创建任务api函数xTaskCreate()时，freertos会在堆中开辟出一片空间，用于存放任务控制信息TCB块和用于存储任务相关变量的栈区Stack。
使用xTaskCreateStatic()在静态区创建任务
TCB的大小构成
TCB信息包括：任务当前执行到哪里了（程序计数器、堆栈指针）、任务的状态（运行、就绪、阻塞、挂起）、任务的优先级、任务的名字、任务等待的事件（比如信号量、队列、通知）等等。
TCB的大小构成取决于FreeRTOSConfig.h头文件的设置，启用了哪些功能

最小设置下96字节
configUSE_TASK_NOTIFICATIONS是1，增加8字节
configUSE_TRACE_FACILITY是1，增加8字节
configUSE_MUTEXES是1,增加8字节




参数
含义
目的




configUSE_TASK_NOTIFICATIONS
启用任务通知
轻量级任务间通信/同步,一个任务可以给另一个任务“发通知”（设置通知值/状态），另一个任务可以“等待通知”（阻塞直到收到通知


configUSE_TRACE_FACILITY
启用跟踪调试设施
系统调试分析（任务状态、事件）


configUSE_MUTEXES
启用互斥锁
启用互斥锁



MSP和PSP栈指针
MSP主堆栈指针(Main stack pointer):

系统启动时默认使用的堆栈指针
用于处理中断和异常
操作系统内核(如FreeRTOS内核)使用

PSP进程堆栈指针(Process stack pointer)

用于每个任务独立的栈指针
每个FreeRTOS任务都有自己的PSP堆栈


示例：


系统启动：使用MSP初始化所有硬件和FreeRTOS


任务切换：

LED任务使用自己的PSP，包含其局部变量ledState
温度任务使用自己的PSP，包含局部变量temperature和数组samples
任务切换时，FreeRTOS保存当前PSP和恢复下一个任务的PSP



中断处理：

当按键中断发生时，无论哪个任务在运行，处理器立即切换到MSP
中断处理完毕后，返回到被中断的任务（使用其PSP）或切换到更高优先级的任务



内存池分配
内存池分配是指在程序编译阶段就分配一定数量的内存块留作备用。当有新的内存需求时，就从内存块分出一部分内存块，若内存块不够了就继续申请新的内存。
当FreeRTOS需要RAM的时候，它会调用pvPortMalloc这个函数而不是Malloc这个系统函数；当它需要释放内存的时候，会调用vPortFree这个函数而不是free这个系统函数。各提供了5种实现方案(heap_1.c,heap_2.c,heap_3.c,heap_4.c,heap_5.c),同时支持定制。stm32cubemx默认采用4。
heap_1
适用于小型嵌入式系统。且只能在调度器启动之前创建任务和其他内核对象。
内存只需要在程序启动调度器前采用first fit算法对内存进行动态分配，之后任务的内存分配在程序的运行周期中保持不变并且无法被释放。
确定性的，不会导致内存碎片化,执行时间固定。
使用静态数组作为堆内存。数组大小由FreeRTOSConfig.h文件中ConfigTOTAL_HEAP_SIZE定义。
xTaskCreate(myTask, &quot;Task1&quot;, 100, NULL, 1, NULL);xQueueCreate(10, sizeof(uint32_t));

heap_2(不推荐使用？)
内存管理也由一个数组实现，大小由FreeRTOSConfig.h文件中configTOTAL_HEAP_SIZE定义
使用best fit算法对内存进行动态分配，允许释放内存。对大的内存块进行分割，但无法合并相连的内存块，容易导致内存的碎片化。
void *buffer = pvPortMalloc(50);  // 分配50字节// 使用内存...vPortFree(buffer);  // 释放内存

heap_3
使用标准C库的malloc() free()函数
添加了互斥锁使其线程安全，调用malloc函数和free函数的时候会临时挂起FreeRTOS的调度器。
// 和标准C库函数名相同，但内部添加了互斥保护void *data = malloc(100);free(data);

heap_4
内存可以自由分配和合并空闲的内存块，并使得整体的性能最优。
使用&quot;首次匹配&quot;算法（使用第一个足够大的空闲块）
Heap_4的分配方案所需要时间是不确定性的，但速度要比malloc和free函数快。
// 频繁分配释放也不会导致严重的内存碎片for(int i=0; i&lt;1000; i++) &#123;    void *temp = pvPortMalloc(random_size());    // 使用内存...    vPortFree(temp);&#125;

heap_5
类似于Heap_4的内存分配技术，但不同于Heap_4只用一个连续的数组表示堆，Heap_5可以用不同的数组空间对内存进行分配。要使用vPortDefineHeapRegions这个函数对不同的数组进行申明。
// 初始化多区域内存// 添加内部SRAM区域HeapRegion_t xHeapRegions[] = &#123;    &#123; (uint8_t*)0x20000000, 0x10000 &#125;,  // 内部SRAM: 64KB    &#123; (uint8_t*)0x60000000, 0x80000 &#125;,  // 外部SRAM: 512KB    &#123; NULL, 0 &#125;  // 终止标记&#125;;vPortDefineHeapRegions(xHeapRegions);// 之后正常使用void *buffer = pvPortMalloc(1000);

内存管理相关函数
size_t xPortGetFreeHeapSize( void );
这个函数会返回当前堆中的空闲空间大小（单位是字节），可以用来优化堆空间大小。比如在系统运行起来后调用xPortGetFreeHeapSize如果返回了3000字节，就可以把堆大小configTOTAL_HEAP_SIZE设置为3000字节多一点。
size_t xPortGetMinimumEverFreeHeapSize( void );
这个函数会返回在系统运行过程中堆空间的最小空闲空间，如果最小空闲空间很小的话可以考虑提高堆大小configTOTAL_HEAP_SIZE的值。这个函数只能在Heap_4或者Heap_5下调用。
void vApplicationMallocFailedHook( void );
这是一个回调函数，需要用户自己实现。如果配置文件中configUSE_MALLOC_FAILED_HOOK 设置为1的话，当堆分配内存失败时会调用此函数。用户可以在此函数中进行错误处理。
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>interrupt-management</title>
    <url>/2025/interrupt-management/</url>
    <content><![CDATA[中断注意事项
在FreeRTOS中，任务程序由内核调度器统一调度和执行，程序的运行情况在一定程度上是稳定可预测的；中断相对而言是由外部环境决定是不可预测的，会对系统引入不确定性，如果使用不当的话会导致系统的失效和不稳定。
对中断的使用要根据实际需求和使用场景来决定，通过合理的配置和与FreeRTOS的中断管理（Interrupt Management）配合可以达到系统的高效能和高稳定性。
FreeRTOS中断管理
在FreeRTOS中中断的优先级和任务的优先级是有区别的,中断拥有更高的权限。

任务的优先级是由用户设置内核管理器管理的软件特性（software feature），与操作系统所在的硬件平台无关。
中断的优先级是由硬件平台相关的硬件特性（hardware feature），在中断代码运行的时候任务的代码将无法运行。即使是拥有最小优先级的中断也会打断拥有最高优先级的任务。
FreeRTOS对于一些系统API函数提供两种版本，一种是供任务调用的，一种是供中断调用的（Interrupt Safe API）。由中断调用的API函数后缀上会有“FromISR”。

当在普通任务中调用FreeRTOS的API函数（如xQueueSend()、xSemaphoreGive()等）时：如果configUSE_PREEMPTION设置为1（抢占式调度）,并且调用API后有更高优先级的任务变为就绪状态,调度器会自动立即切换到那个更高优先级的任务。
当在中断处理时调用特殊的&quot;FromISR&quot;版本的API（如xQueueSendFromISR()、xSemaphoreGiveFromISR()等），如果有更高级别的任务进入就绪态，系统不会在中断处理函数结束后自动切换任务。而是需要手动根据&quot;FromISR&quot;版本函数的一个自带参数pxHigherPriorityTaskWoken参数的值，调用portTIELD_FROM_ISR(pxHigherPriorityTaskWoken)来手动决定是否切换任务。

如果API的调用导致更高级别任务进入就绪态，pxHigherPriorityTaskWoken参数会被设为pdTRUE

// 中断处理函数void vUARTInterruptHandler(void)&#123;    BaseType_t xHigherPriorityTaskWoken = pdFALSE;    char receivedChar;        // 假设收到一个字符    receivedChar = UART_READ_REGISTER;        // 将字符发送到队列，可能会唤醒等待队列的高优先级任务    xQueueSendFromISR(xCharQueue, &amp;receivedChar, &amp;xHigherPriorityTaskWoken);        // 中断结束前，检查是否需要任务切换    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);&#125;
延迟中断处理
延迟中断处理是一种设计模式：

最小化的中断服务程序(ISR)：只做必要的紧急处理
专门的高优先级任务：处理剩余的中断相关工作

优点：

缩短中断响应时间：ISR应尽可能短，减少中断禁用时间
提高系统响应性：复杂处理放在任务中，不阻塞其他中断
简化代码：在任务中可以使用所有FreeRTOS API，而不仅限于FromISR版本
优先级控制：通过任务优先级控制中断处理的优先顺序
便于调试：任务比ISR更容易调试

// 中断服务程序 - 硬件直接调用void InterruptHandling()&#123;   RecordInterrupt();     // 记录中断信息（可能存储到全局变量或队列）   ClearInterruptFlag();  // 清除中断标志，允许新的中断发生   portYIELD_FROM_ISR(pdTRUE); // 强制任务切换，让高优先级任务立即执行&#125;// 中断处理任务 - 由调度器调度void vInterruptHandling(void const * argument)&#123;   // 无限循环，等待中断发生   for(;;) &#123;       ProcessInterrupt(); // 处理之前记录的中断信息   &#125;&#125;
工作流程：

硬件中断触发，进入InterruptHandling()函数
ISR只做简单的记录和清除标志工作
ISR调用portYIELD_FROM_ISR(pdTRUE)强制任务切换
调度器选择最高优先级的就绪任务
如果中断处理任务vInterruptHandling()是最高优先级，它会立即执行
中断处理任务分析并处理中断数据

一般还会搭配信号量，队列等机制来避免一直处于高优先级就绪态，阻塞其他任务执行。
void vInterruptHandlingTask(void *pvParameters)&#123;    for(;;) &#123;        // 等待中断通知，这里任务进入阻塞态        // 只有当接收到通知时，任务才会变为就绪态        if(xSemaphoreTake(xInterruptSemaphore, portMAX_DELAY) == pdTRUE) &#123;                        // 处理中断相关的工作            ProcessInterrupt();                        // 处理完成后，循环回到开头，再次尝试获取信号量            // 如果没有新的中断发生，任务会再次阻塞在这里        &#125;    &#125;&#125;
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>pi5-ImmortalWrt</title>
    <url>/2025/pi5-ImmortalWrt/</url>
    <content><![CDATA[刷入固件

注：使用rpi-imager重刷固件时，必须刷写与之前不同格式的镜像(ext4、squashfs)。否则似乎并没有格式化。原因不清楚，如果在原有基础上升级？或者重刷，或许应该使用官方提供的另一款镜像？

先不要插网线，启动树莓派。
配置
连接名为&quot;ImmortWrt&quot;的无线网，然后访问192.168.1.1进入管理界面。默认用户名root，密码passwd。

将树莓派作为主路由，光猫处于桥接模式，引出网线插到树莓派网口接入WAN口,板载无线网卡作为LAN
口供连接使用。树莓派同时负责拨号上网。
配置LAN口


注意设备的选择，选择无线
ipv4地址决定了访问管理界面输入的网址

配置WAN口


选择PPPoE拨号，输入宽带密码(忘记编辑短信czkdmn发给10086重置密码)
设备选择有线网卡
听说关闭ipv6能提高网速？

至此可保存一下，试试是否成功，然后可以插上网线了。
配置无线接入点
很简单。
更改wifi名：

更改wifi密码：

注意：保存更改时，要重新连接到修改后的wifi才能修改成功。不然会在时间结束后弹出配置失败。
安装插件待更新
]]></content>
  </entry>
  <entry>
    <title>pid</title>
    <url>/2025/pid/</url>
    <content><![CDATA[pid通俗解释
单级PID
//首先定义PID结构体用于存放一个PID的数据typedef struct&#123;   	float kp, ki, kd; //三个系数    float error, lastError; //误差、上次误差    float integral, maxIntegral; //积分、积分限幅    float output, maxOutput; //输出、输出限幅&#125;PID; //用于初始化pid参数的函数void PID_Init(PID *pid, float p, float i, float d, float maxI, float maxOut)&#123;    pid-&gt;kp = p;    pid-&gt;ki = i;    pid-&gt;kd = d;    pid-&gt;maxIntegral = maxI;    pid-&gt;maxOutput = maxOut;&#125; //进行一次pid计算//参数为(pid结构体,目标值,反馈值)，计算结果放在pid结构体的output成员中void PID_Calc(PID *pid, float reference, float feedback)&#123; 	//更新数据    pid-&gt;lastError = pid-&gt;error; //将旧error存起来    pid-&gt;error = reference - feedback; //计算新error    //计算微分    float dout = (pid-&gt;error - pid-&gt;lastError) * pid-&gt;kd;    //计算比例    float pout = pid-&gt;error * pid-&gt;kp;    //计算积分    pid-&gt;integral += pid-&gt;error * pid-&gt;ki;    //积分限幅    if(pid-&gt;integral &gt; pid-&gt;maxIntegral) pid-&gt;integral = pid-&gt;maxIntegral;    else if(pid-&gt;integral &lt; -pid-&gt;maxIntegral) pid-&gt;integral = -pid-&gt;maxIntegral;    //计算输出    pid-&gt;output = pout+dout + pid-&gt;integral;    //输出限幅    if(pid-&gt;output &gt; pid-&gt;maxOutput) pid-&gt;output =   pid-&gt;maxOutput;    else if(pid-&gt;output &lt; -pid-&gt;maxOutput) pid-&gt;output = -pid-&gt;maxOutput;&#125; PID mypid = &#123;0&#125;; //创建一个PID结构体变量 int main()&#123;    //...这里有些其他初始化代码    PID_Init(&amp;mypid, 10, 1, 5, 800, 1000); //初始化PID参数    while(1)//进入循环运行    &#123;        float feedbackValue = ...; //这里获取到被控对象的反馈值        float targetValue = ...; //这里获取到目标值        PID_Calc(&amp;mypid, targetValue, feedbackValue); //进行PID计算，结果在output成员变量中        设定执行器输出大小(mypid.output);        delay(10); //等待一定时间再开始下一次循环    &#125;&#125;

PID三个环节作用

比例：起主要控制作用，使反馈量向目标值靠拢，但可能导致振荡
积分：消除稳态误差，但会增加超调量
微分：产生阻尼效果，抑制振荡和超调，但会降低响应速度

例子

对电机转速进行控制
可用条件：已知电机的实时转速，并且可控制电机中流过的电流大小
PID目标值：需要电机达到的转速
PID反馈值：电机的实时转速
PID输出值：电机中流过的电流大小
分析：电机中流过的电流大小近似正比于电机的扭矩，也就近似正比于电机角加速度的大小，是转速的低阶物理量，因此可以用电流大小作为输出值

串级PID
单级PID目标值和反馈值经过一次PID计算就得到输出值并直接作为控制量，但如果目标物理量和输出物理量之间不止差了一阶的话，中间阶次的物理量我们是无法控制的。比如：目标物理量是位置，输出物理量是加速度，则小球的速度是无法控制的。
而串级PID就可以改善这一点。串级PID其实就是两个单级PID“串”在一起组成的，它的信号框图如下：

外环和内环就分别是一个单级PID，每个单级PID就如我们之前所说，需要获取一个目标值和一个反馈值，然后产生一个输出值。串级PID中两个环相“串”的方式就是将外环的输出作为内环的目标值。
案例

可用条件：小球实时位置、小球实时速度、施加在小球上的控制力
目标值：小球目标位置
外环反馈：小球实时位置
内环反馈：小球实时速度
输出值：施加在小球上的控制力


内环与小球构成了一个恒速系统，PID内环负责小球的速度控制；而如果把内环和小球看作一个整体被控对象，外环又与这个对象一起构成了一个位置控制系统，外环负责位置控制；总体来说，外环负责根据小球位置误差计算出小球需要达到的速度，而内环负责计算出控制力使小球达到这个目标速度，两个环协同工作，就可以完成任务了。
串级PID的内环一般负责低阶物理量(通常是变化更快、更基础的物理量)的调节，而外环负责高阶物理量(通常是变化较慢、更关注的最终目标量、高阶量的导数或相关量)的调节并计算出低阶物理量的目标值。

任务：对电机进行串级角度控制
可用条件：电机实时角度、电机实时转速、可以控制电机电流大小
外环目标值：需要电机达到的角度
外环反馈值：电机的实时角度
内环反馈值：电机的实时速度
输出值：电机电流大小
分析：外环负责电机角度控制，根据电机目标角度和反馈角度计算出目标转速；内环负责转速控制，根据速度反馈和目标转速计算出电流

代码实现
//此处需要插入上面的单级PID相关代码 //串级PID的结构体，包含两个单级PIDtypedef struct&#123;    PID inner; //内环    PID outer; //外环    float output; //串级输出，等于inner.output&#125;CascadePID; //串级PID的计算函数//参数(PID结构体,外环目标值,外环反馈值,内环反馈值)void PID_CascadeCalc(CascadePID *pid, float outerRef, float outerFdb, float innerFdb)&#123;    PID_Calc(&amp;pid-&gt;outer, outerRef, outerFdb); //计算外环    PID_Calc(&amp;pid-&gt;inner, pid-&gt;outer.output, innerFdb); //计算内环    pid-&gt;output = pid-&gt;inner.output; //内环输出就是串级PID的输出&#125; CascadePID mypid = &#123;0&#125;; //创建串级PID结构体变量 int main()&#123;    //...其他初始化代码    PID_Init(&amp;mypid.inner, 10, 0, 0, 0, 1000); //初始化内环参数    PID_Init(&amp;mypid.outer, 5, 0, 5, 0, 100); //初始化外环参数    while(1) //进入循环运行    &#123;        float outerTarget = ...; //获取外环目标值        float outerFeedback = ...; //获取外环反馈值        float innerFeedback = ...; //获取内环反馈值        PID_CascadeCalc(&amp;mypid, outerTarget, outerFeedback, innerFeedback); //进行PID计算        设定执行机构输出大小(mypid.output);        delay(10); //延时一段时间    &#125;&#125;
调参
需要先断开两环的连接，手动指定内环目标值，进行内环调参，当内环控制效果较好后再接上外环进行外环调参，具体的调参方法与单级PID相同。
]]></content>
      <tags>
        <tag>电控</tag>
      </tags>
  </entry>
  <entry>
    <title>queue-management</title>
    <url>/2025/queue-management/</url>
    <content><![CDATA[进程间通信方式


a图采用进程间共享内存,共用和交互数据更快
b图采用消息队列，更通用更稳定
全局变量不太线程安全

TaskA和B之间通过队列交互数据，A写B读。

队列的实现方式

复制队列(Queue by copy)：写入队列的数据每个字节都被完整复制到队列中。
引用队列(Queue by reference):写入队列的是数据的引用或指针。

FreeRTOS采用复制队列。优势如下：

有些储存在栈上的变量在函数运行结束后是将会被销毁的，如果采用引用队列的话引用会失效
发送数据的任务可以重复使用变量，采用引用队列的话每发送一个数据需要一个新的变量
发送队列数据的任务和接受队列数据的任务之间是没有耦合的，两者互相不影响
复制队列可以通过储存指向数据块的指针实现引用队列的功能

一个队列可以有对个写入数据的任务和多个读取数据的任务。
阻塞时间(block time)：当队列数据为空时，任务处于阻塞状态的时间。
当任务尝试读取队列数据时，可以设置一个阻塞时间(xQueueReceive())。 当有数据在队列或到达阻塞时间时，任务进入就绪状态。如果有多个任务同时在阻塞状态等待队列数据，优先级高的任务会在数据到达时进入就绪状态；在优先级相同的时候，等待时间长的任务会进入就绪状态。
同理可得多个任务写入队列的情景。
同时，FreeRTOS 允许任务使用队列集同时等待多个队列，当队列集中的任何一个队列收到数据时，任务可以被唤醒。
常见API
FreeRTOS API

创建队列

QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )

返回值是QueueHandle_t具柄类型，表示的是对所创建队列的一个引用句柄。FreeRTOS从FreeRTOS的堆中指定一些内存空间给队列使用。如果堆中没有足够空间给队列使用的话函数的返回值会是NULL
uxQueueLength：队列包含数据的最大长度
uxItemSize：每个数据占用的字节大小


发送数据

  BaseType_t xQueueSend( QueueHandle_t xQueue, const void * pvItemToQueue,TickType_t xTicksToWait )
xQueueSend（）函数用于将数据发送到队列（具体一点就是队列的尾部）。如果要在中断程序调用的话需要使用xQueueSendFromISR（）函数（只能在中断函数中使用）。

xQueue 队列的具柄，来自于xQueueCreate（）的返回值
pvItemToQueue 所发送数据的引用，然后这些数据会被复制到队列中
xTicksToWait 队列如果满时发送任务的阻塞时间（block time），上文已经介绍过，可以通过pdMS_TO_TICKS()把时间转换成节拍数。如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中INCLUDE_vTaskSuspend参数设置为1）
返回值 发送数据成功时返回pdPASS，失败时返回errQUEUE_FULL

BaseType_t xQueueSendToFront( QueueHandle_t xQueue, const void * pvItemToQueue,TickType_t xTicksToWait )BaseType_t xQueueSendToBack( QueueHandle_t xQueue, const void * pvItemToQueue,TickType_t xTicksToWait )
可选择发送到队列开头还是结尾，xQueueSendToBack本质和xQueueSend是一样的。

接收数据

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer,TickType_t xTicksToWait )
xQueueReceive用于从队列里读取数据，同时读取到的数据会被从队列中移除。

xQueue 队列的具柄，来自于xQueueCreate（）的返回值
pvBuffer 指向内存空间的一个引用，读取的数据会被复制到这片内存
xTicksToWait 队列如果空时接送任务的阻塞时间（block time），如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中INCLUDE_vTaskSuspend参数设置为1）

返回值 接收数据成功时返回pdPASS，失败时返回errQUEUE_EMPTY

查询队列数据数量

UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue )

查看数据

    BaseType_t xQueuePeek(QueueHandle_t xQueue,void *pvBuffer,TickType_t xTicksToWait);
查看队列前面的数据项，但不会将其移除。中断中使用xQueuePeekFromISR

xQueue：要读取的队列句柄。
pvBuffer：指向用于存储队列项的缓冲区的指针。
xTicksToWait：如果队列为空，任务等待的最大时间（tick 数）；如果为 0，则立即返回。
返回值 成功读取pdTRUE，没读到返回pdFALSE。

CMSIS RTOS API

图形化配置

Item Size可以换成用户自定义的结构体类型。
CMSIS中邮件队列
引用队列的实现，叫做邮件队列（mail queue），传递的是储存数据块的地址指针。

]]></content>
      <categories>
        <category>嵌入式</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>ros2-base</title>
    <url>/2025/ros2-base/</url>
    <content><![CDATA[DDS
DDS（Data Distribution Service）是一种基于数据的通信中间件标准，目的是建立分布式系统的高质量数据通信。它采用发布-订阅模型，通过主题（Topic）实现数据的逻辑分组和管理，支持灵活的数据传输策略。
DDS的核心模型是DSCP（Data-centric Publish-Subscribe）模型，定义了数据发布者和数据订阅者之间的交互方式。具体包括以下几个角色：

Domain：DDS域，可以理解为一个通讯平面，由Domain ID唯一标识，用于标识一个或多个DomainParticipant，只有在同个域的DomainParticipant才允许通讯
DomainParticipant：域参与者，是域中的一个实体（可以具象为一个设备，或者设备中的一个进程），是数据发布者、订阅者和主题的创建和管理者，负责管理DDS中的实体对象和通信配置
Publisher/Subscriber：发布者/订阅者，由DomainParticipant创建，发布者负责将数据发布到特定的主题（Topic）中，而订阅者则通过订阅相关主题来接收所需的数据
DataWriter/DataReader：数据写入/读取者，由Publisher/Subscriber创建，DataWriter负责将数据写入到特定的主题中，而DataReader负责从主题中读取相应的数据
Topic：主题是DCPS中定义数据传输的逻辑分类和组织单元。它可以看作是一种数据的标签，用于区分不同类型的数据

这些角色之间的关系如下：
Domain-&gt; DomainParticipant -&gt; Publisher/Subscriber -&gt; DataWriter/DataReader
编程基础
g++编译
// 包含rclcpp头文件，如果Vscode显示红色的波浪线也没关系// 我们只是把VsCode当记事本而已，谁会在意记事本对代码的看法呢，不是吗？#include &quot;rclcpp/rclcpp.hpp&quot;int main(int argc, char **argv)&#123;    // 调用rclcpp的初始化函数    rclcpp::init(argc, argv);    // 调用rclcpp的循环运行我们创建的first_node节点    rclcpp::spin(std::make_shared&lt;rclcpp::Node&gt;(&quot;first_node&quot;));    return 0;&#125;
g++ first_ros2_node.cpp
报错：

No such file or directory——没有那个文件或目录


g++: error: first_ros2_node.cpp: 没有那个文件或目录
g++: fatal error: no input files
compilation terminated.

解决：

-I 添加头文件路径 套娃式，全部加入
g++ first_ros2_node.cpp -I  /opt/ros/foxy/include/rclcpp/


undefined reference to xxxxx
g++找不到库文件

解决：

-L 添加库文件路径
-lrclcpp -lrcutils  指定链接到 rclcpp rcutils库

make
cmake
工作空间
工作空间（Workspace）是一个目录结构，用于组织和管理多个ROS 2包。通常包括四个主要目录：

src（包含所有源代码包。每个包是一个独立的目录，包含包的源代码、头文件、配置文件等）
build（包含构建过程中生成的中间文件。这些文件在构建过程中由colcon工具生成，用于编译和链接。）
install（包含构建完成后生成的可执行文件、库文件和配置文件。这些文件在构建完成后由colcon工具安装到此目录，用于运行和测试。）
log（包含构建过程中的日志文件。这些文件记录了构建过程中的详细信息，方便调试和排查问题）

新建一个工作空间：

mkdir -p &lt;workspace_name&gt;/src
cd &lt;workspace_name&gt;
colcon build   //可以省略，构建包时一并进行
cd &lt;workspace_name&gt;/src

功能包
功能包（Feature Package）是一个特殊的包(就等于包？)，它提供了一组相关的功能或服务，通常用于扩展ROS 2的核心功能。功能包可以包含节点、服务、消息、动作等，也可以提供工具、库或配置文件，以支持特定的功能或任务。
ROS2中功能包根据编译方式的不同分为三种类型：

ament_python，适用于python程序
cmake，适用于C++
ament_cmake，适用于C++程序,是cmake的增强版

结构
一个典型的ROS 2包通常包含以下文件和目录：

epackage.xml
这是包的描述文件，包含包的元数据，如包名、版本、作者、依赖关系等。它用于定义包的基本信息和依赖关系，帮助ROS 2构建系统（如colcon）了解如何构建和安装包。
CMakeLists.txt
这是包的构建脚本，使用CMake语法编写。它定义了如何构建包中的代码，包括编译源文件、链接库、生成可执行文件等。
src目录
包含源代码文件，如C++或Python文件。这些文件定义了包中的节点、库等。
include目录
包含头文件，这些头文件定义了包中的类、函数等。
launch目录
包含启动文件，这些文件定义了如何启动包中的节点。启动文件通常使用XML或Python编写。
相关代码

获取
安装获取——sudo apt install ros-&lt;version代号&gt;-package_name
也可手动编译获取（手动source工作空间的install目录 ）
常用命令

创建功能包

ros2 pkg create &lt;package-name&gt;  --build-type  &#123;cmake,ament_cmake,ament_python&#125;  --dependencies &lt;依赖名字&gt; --node-name NAME  
自动生成NAME.cpp源文件 注意别加后缀

列出可执行文件

ros2 pkg executables &lt;package_name&gt;ros2 pkg executables turtlesim

列出所有的包

ros2 pkg list 

输出某个包所在路径前缀

ros2 pkg prefix &lt;package_name&gt;

列出包的清单描述文件

ros2 pkg xml &lt;package_name&gt;
节点
节点可以理解为相互独立的进程。每一个节点只负责一个单独的模块化功能，比如一个节点负责控制车轮转动，一个节点负责从激光雷达获取数据、一个节点负责处理激光雷达的数据、一个节点负责定位等等
相关命令

启动包下的节点

ros2 run &lt;package_name&gt; &lt;executable_name&gt;```  2. 查看节点列表```bashros2 node list   

查看节点信息

ros2 node info &lt;node_name&gt;        

重映射节点名称

ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle    
–ros-args  后面跟上相关参数

运行节点时设置参数

ros2 run example_parameters_rclcpp parameters_basic --ros-args -p rcl_log_level:=10
Colcon
功能包构建工具，可以用来编译代码
相关代码

允许通过更改src下的部分文件来改变install（重要）每次调整 python 脚本时都不必重新build了  ???

colcon build --symlink-install     

只编译一个包

colcon biuld --packages-select YOUR_PKG_NAME           

编译整个工程

colcon build         

不编译测试单元

colcon build --packages-select YOUR_PKG_NAME --cmake-args -DBUILD_TESTING=0    

运行编译的包的测试

colcon test        
一般流程
建空间——建包——写源代码——修改CMakelists.txt——编译——加载setup.bash文件——执行
]]></content>
      <tags>
        <tag>ros2</tag>
      </tags>
  </entry>
  <entry>
    <title>ros2-communication</title>
    <url>/2025/ros2-communication/</url>
    <content><![CDATA[接口
接口：通信时使用的数据载体（特定的格式），由接口文件定义

msg文件：用于话题通信，
srv文件：用于服务通信
action文件：用于动作通信

参数通信不使用，操作参数对象

话题通信：
基于发布订阅模式
除了一个节点发布，一个节点接受的形式外，ROS2话题通信其实还可以是1对n, n对1, n对n的，1对n

发布者：
#include &lt;rclcpp/rclcpp.hpp&gt;#include &quot;std_msgs/msg/string.hpp&quot;using namespace std::chrono_literals;//1s 代表一秒 std::chrono::seconds(1)class Talker :public rclcpp::Node&#123;public:  //将节点命名为talker,初始化count  Talker() :Node(&quot;talker&quot;),count(0))&#123;    //打印日志，说明节点被创建    RCLCPP_INFO(this-&gt;get_logger(),&quot;a talker created&quot;);    //创建一个发布者  话题为chat   队列长为10    publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;chat&quot;,10);    //创建一个每隔1秒触发一次的定时器，并将定时器的回调函数设置为当前对象的on_timer成员函数    timer_ =  this-&gt;create_wall_timer(1s,std::bind(&amp;Talker::on_timer,this));  &#125;private:  //创建一个定时器的指针  rclcpp::TimerBase::SharedPtr timer_ ;    //创建一个发布string类型数据的成员指针  rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher_;  //无符号长整型  size_t count;  void on_timer()&#123;    //创建一个String类的实例    //局部变量！！！！每次创建一个新的，函数结束后销毁，不会资源浪费    //也可以在函数外部预定义    auto message = std_msgs::msg::String();    //to_string 转化成字符串    message.data = &quot;hello world!&quot; + std::to_string(count++);    //    RCLCPP_INFO(this-&gt;get_logger(),&quot;发布者发布消息：%s&quot;,message.data.c_str());    //publish：这是rclcpp::Publisher类的一个成员函数，用于发布消息。    //这个函数接受一个消息对象作为参数，并将其发送到指定的主题上。    publisher_-&gt;publish(message);  &#125; &#125;;int main(int argc, char ** argv)&#123;  //初始化rcl客户端  rclcpp::init(argc,argv);  //回旋，一直执行回调函数，直到节点被关闭  //std::make_shared&lt;T&gt;() 是一个模板函数，用于创建一个std::shared_ptr&lt;T&gt;对象。它不仅创建了一个共享指针，还同时创建了一个T类型的对象实例。  rclcpp::spin(std::make_shared&lt;Talker&gt;());  //释放资源  rclcpp::shutdown();  return 0;&#125;

订阅方

回调函数传入参数类型不能是std_msgs::msg::String的引用
create_subscription方法传递的是消息的共享指针，而不是消息的引用。正确的参数类型应该是const std_msgs::msg::String::SharedPtr
#include &lt;rclcpp/rclcpp.hpp&gt;#include &lt;std_msgs/msg/string.hpp&gt;class Listener : public rclcpp::Node&#123;public:    Listener() : Node(&quot;listener_node_cpp&quot;)&#123;        RCLCPP_INFO(this-&gt;get_logger(),&quot;订阅者已创建&quot;);        //接收到信息就执行回调函数        //create_subscription函数的作用是创建一个订阅者（subscriber），该订阅者会监听指定主题（topic）上的消息。        //当有消息发布到该主题时，create_subscription会将接收到的消息传递给指定的回调函数（callback function）。        subscription_ = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;chat&quot;,10,std::bind(&amp;Listener::do_cb,this,std::placeholders::_1));    &#125;private:    //注意传入消息类型    void do_cb(const std_msgs::msg::String::SharedPtr message)&#123;        RCLCPP_INFO(this-&gt;get_logger(),&quot;订阅到的消息是：%s&quot;,message-&gt;data.c_str());    &#125;        rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr subscription_;&#125;;int main(int argc, char** argv)&#123;    rclcpp::init(argc,argv);    rclcpp::spin(std::make_shared&lt;Listener&gt;());    rclcpp::shutdown();    return 0;&#125;

生成代码片段
左下角设置——代码片段——cpp

自定义接口文件——编译前保存！！！！
文件名首字母大写
xml文件配置
&lt;!-- 编译依赖--&gt;  &lt;build_depend&gt;&lt;/build_depend&gt;    &lt;!--执行依赖 --&gt;  &lt;exec_depend&gt;&lt;/exec_depend&gt;    &lt;!--声明当前包所属功能包组 --&gt;  &lt;member_of_group&gt;&lt;/member_of_group&gt;
ros2 pkg list | grep -i NAME         筛选出来，不用记

CMakeLists.txt
find_package(rosidl_default_generators REQUIRED)rosidl_generate_interfaces(  $&#123;PROJECT_NAME&#125;  &quot;msg/Student.msg&quot;)

使用自定义接口文件要包含路径
#include &lt;rclcpp/rclcpp.hpp&gt;#include &lt;base_interfaces_demo/msg/student.hpp&gt;    using namespace std::chrono_literals;//1s 代表一秒 std::chrono::seconds(1)using base_interfaces_demo::msg::Student;class TalkerStu :public rclcpp::Node&#123;public:    TalkerStu() :Node(&quot;talker_stu&quot;)&#123;        publisher_ = this-&gt;create_publisher&lt;Student&gt;(&quot;Student&quot;,10);        timer_ = this-&gt;create_wall_timer(1s,std::bind(&amp;TalkerStu::callback,this));    &#125;private:    rclcpp::Publisher&lt;Student&gt;::SharedPtr publisher_;     rclcpp::TimerBase::SharedPtr timer_;    Student stu;    void callback()&#123;        stu.name  = &quot;lihua&quot;;        stu.age = 12;        stu.height = 180.0;        publisher_-&gt;publish(stu);        RCLCPP_INFO(this-&gt;get_logger(),&quot;发布消息：%s,%d,%lf&quot;,stu.name.c_str(),stu.age,stu.height);    &#125;&#125;;int main(int argc,char **argv)&#123;    rclcpp::init(argc,argv);    rclcpp::spin(std::make_shared&lt;TalkerStu&gt;());    rclcpp::shutdown();    return 0;&#125;
#include &lt;rclcpp/rclcpp.hpp&gt;#include &lt;base_interfaces_demo/msg/student.hpp&gt;using base_interfaces_demo::msg::Student;using namespace std::chrono_literals;class ListenerStu :public rclcpp::Node&#123;public:    ListenerStu() :Node(&quot;listener_stu&quot;)&#123;        RCLCPP_INFO(this-&gt;get_logger(),&quot;订阅者已创建&quot;);        subscription_ = this-&gt;create_subscription&lt;Student&gt;(&quot;Student&quot;,10,std::bind(&amp;ListenerStu::callback,this,std::placeholders::_1));       &#125;private:    rclcpp::Subscription&lt;Student&gt;::SharedPtr subscription_;    void callback(const Student::SharedPtr message)&#123;        RCLCPP_INFO(this-&gt;get_logger(),&quot;订阅者已接收：%s,%d,%lf&quot;,message-&gt;name.c_str(),message-&gt;age,message-&gt;height);    &#125;&#125;;int main(int argc,char **argv)&#123;    rclcpp::init(argc,argv);            rclcpp::shutdown();    return 0;&#125;

服务通信
一对多，一个服务端，多个客户端
自定义接口文件
请求数据  ---  响应数据  
在之前的基础上，修改CMakeLists.txt  ——rosidl_generate_interfaces即可
服务端
#include &lt;rclcpp/rclcpp.hpp&gt;#include &lt;base_interfaces_demo/srv/addints.hpp&gt;using base_interfaces_demo::srv::Addints;using std::placeholders::_1;using std::placeholders::_2;class AddIntServer :public rclcpp::Node&#123;public:  AddIntServer() :Node(&quot;add_int_server&quot;)&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;服务端节点创建成功&quot;);      service_ = this-&gt;create_service&lt;Addints&gt;(&quot;add_ints&quot;,std::bind(&amp;AddIntServer::sum,this,_1,_2));  &#125;private:  rclcpp::Service&lt;Addints&gt;::SharedPtr service_;  void sum(const Addints::Request::SharedPtr req,const Addints::Response::SharedPtr res)&#123;    res-&gt;sum = req-&gt;num1 + req-&gt;num2;    RCLCPP_INFO(this-&gt;get_logger(),&quot;%d + %d = %d&quot;,req-&gt;num1,req-&gt;num2,res-&gt;sum);  &#125;&#125;;int main(int argc,char **argv)&#123;  rclcpp::init(argc,argv);    rclcpp::spin(std::make_shared&lt;AddIntServer&gt;());  rclcpp::shutdown();  return 0;&#125;
测试：
ros2 service call /add_ints base_interfaces_demo/srv/Addints “&#123;'num1':10,'num2':30&#125;&quot;
rclcpp::ok();
rclcpp::get_logger();     不依赖于context

客户端
main函数中需要判断提交参数是否正确
自定义节点类中要包括 判断是否连接到服务端
#include &lt;rclcpp/rclcpp.hpp&gt;#include &lt;base_interfaces_demo/srv/addints.hpp&gt;using base_interfaces_demo::srv::Addints;using namespace std::chrono_literals;class AddIntClient :public rclcpp::Node &#123;public:    AddIntClient() :Node(&quot;add_int_client&quot;)&#123;        RCLCPP_INFO(this-&gt;get_logger(),&quot;客户端节点创建&quot;);        client_ = this-&gt;create_client&lt;Addints&gt;(&quot;add_ints&quot;);    &#125;   //连接服务器   bool connect_server()&#123;      //以1s为超时时间，连接不上，一直连接        while(!client_ -&gt; wait_for_service(1s))&#123;            //rclcpp::ok()函数来检查ROS 2节点是否仍在运行            //如果节点被请求停止（例如，通过按下Ctrl+C），rclcpp::ok()会返回false            if(!rclcpp::ok())&#123;                RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;),&quot;强制退出&quot;);                return false;            &#125;            RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;),&quot;服务器连接中&quot;);        &#125;        return true;          &#125;    //发送请求函数    //参数两个整形数据 返回服务器处理后的结果    rclcpp::Client&lt;Addints&gt;::SharedFuture send_request(int num1,int num2)&#123;        auto request = std::make_shared&lt;Addints::Request&gt;();        request-&gt;num1 = num1;        request-&gt;num2 = num2;       //rclcpp::Client&lt;base_interfaces_demo::srv::Addints&gt;::SharedFuture        //async_send_request(std::shared_ptr&lt;base_interfaces_demo::srv::Addints_Request&gt; request)                return client_-&gt;async_send_request(request);    &#125;private:    rclcpp::Client&lt;Addints&gt;::SharedPtr  client_;&#125;;int main(int argc,char **argv)&#123;    if(argc != 3)&#123;        RCLCPP_ERROR(rclcpp::get_logger(&quot;rclcpp&quot;),&quot;请提交两个整型数据&quot;);        return 1;    &#125;    rclcpp::init(argc,argv);    auto client = std::make_shared&lt;AddIntClient&gt;();    bool flag = client-&gt;connect_server();    //判断是否链接上服务器    if(!flag)&#123;        RCLCPP_INFO(rclcpp::get_logger(&quot;rclcpp&quot;),&quot;服务器连接失败&quot;);        return 0;    &#125;    //调用请求提交函数，接收并处理响应结果    auto future = client-&gt;send_request(atoi(argv[1]),atoi(argv[2]));        //处理响应    if(rclcpp::spin_until_future_complete(client,future) == rclcpp::FutureReturnCode::SUCCESS)&#123;        RCLCPP_INFO(client-&gt;get_logger(),&quot;响应成功!sum = %d&quot;,future.get()-&gt;sum);    &#125;else&#123;        RCLCPP_INFO(client-&gt;get_logger(),&quot;sd&quot;);    &#125;        rclcpp::shutdown();    return 0;&#125;

动作通信
自定义接口文件
请求数据  ---   响应数据  ---   反馈数据  
xml：
&lt;!-- action补充--&gt;  &lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;  &lt;depend&gt;action_msgs&lt;/depend&gt;
CMakeLists.txt补充rosidl_generate_interfaces
服务端
ros2 action send_goal /get_sum base_interfaces_demo/action/Progress -f &quot;&#123;'num':10&#125;&quot;
rclcpp::Rate 的构造函数接受一个频率值（单位为 Hz），表示每秒执行的次数。例如：
rclcpp::Rate rate(1.0);  // 每秒执行 1 次，即每秒运行一次循环
rate.sleep() 方法来暂停代码的执行，直到下一次循环的时间点。如果当前循环提前完成，rate.sleep() 会阻塞当前线程，直到达到预期的频率。
#include &lt;rclcpp/rclcpp.hpp&gt;#include &lt;rclcpp_action/rclcpp_action.hpp&gt;#include &lt;base_interfaces_demo/action/progress.hpp&gt;using base_interfaces_demo::action::Progress;using std::placeholders::_1;using std::placeholders::_2;class ActionService :public rclcpp::Node&#123;public:  ActionService() :Node(&quot;action_service&quot;)&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;服务器已创建!&quot;);        //rclcpp_action::Server&lt;ActionT&gt;::SharedPtr     //create_server&lt;ActionT, NodeT&gt;    //(NodeT node,     //const std::string &amp;name,     //rclcpp_action::Server&lt;ActionT&gt;::GoalCallback handle_goal,     //rclcpp_action::Server&lt;ActionT&gt;::CancelCallback handle_cancel,     //rclcpp_action::Server&lt;ActionT&gt;::AcceptedCallback handle_accepted,    // const rcl_action_server_options_t &amp;options = rcl_action_server_get_default_options(), rclcpp::CallbackGroup::SharedPtr group = nullptr)//All provided callback functions must be non-blocking.    server_ = rclcpp_action::create_server&lt;Progress&gt;(      this,      &quot;get_sum&quot;,     std::bind(&amp;ActionService::handle_goal,this,_1,_2),     std::bind(&amp;ActionService::handle_cancel,this,_1),     std::bind(&amp;ActionService::handle_accepted,this,_1)     );  &#125;private:  rclcpp_action::Server&lt;Progress&gt;::SharedPtr server_;  //处理提交的目标值，注意参数  rclcpp_action::GoalResponse handle_goal(const rclcpp_action::GoalUUID&amp; uuid,std::shared_ptr&lt;const Progress::Goal&gt; goal)&#123;    //判断提交的数字是否大于1，大于接受，小于拒绝    if(goal-&gt;num &lt;= 1)&#123;      RCLCPP_INFO(this-&gt;get_logger(),&quot;提交数据小于1&quot;);      return rclcpp_action::GoalResponse::REJECT;    &#125;    RCLCPP_INFO(this-&gt;get_logger(),&quot;提交数据合法&quot;);    return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;  &#125;  //处理取消请求  //客户端可发送取消请求  rclcpp_action::CancelResponse handle_cancel(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Progress&gt;&gt; goal_handle)&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;任务已取消&quot;);    return rclcpp_action::CancelResponse::ACCEPT;  &#125;  //生成连续反馈和最终响应  void execute(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Progress&gt;&gt; goal_handle)&#123;    //生成连续反馈给客户端 goal_handle-&gt;publish_feedback()    //void publish_feedback(std::shared_ptr&lt;base_interfaces_demo::action::Progress_Feedback&gt; feedback_msg)    //首先获取目标值，遍历然后累加，每循环一次计算进度，作为连续反馈发布    int num = goal_handle-&gt;get_goal()-&gt;num;    int sum=0;    double progress;    auto feedback = std::make_shared&lt;Progress::Feedback&gt;();    auto result = std::make_shared&lt;Progress::Result&gt;();    //设置休眠,1s一次    rclcpp::Rate rate(1.0);    for(int i = 1;i&lt;=num;i++)&#123;      sum+=i;      progress = i / (double)num;      feedback-&gt;progress = progress;      goal_handle-&gt;publish_feedback(feedback);      RCLCPP_INFO(this-&gt;get_logger(),&quot;连续反馈中，进度：%.2f&quot;,progress);      //判断是否接收到了取消请求      //true——接收到取消请求      if(goal_handle-&gt;is_canceling())&#123;              //canceled(std::shared_ptr&lt;base_interfaces_demo::action::Progress_Result&gt; result_msg)        //取消时发送最终结果        result-&gt;sum = sum;        goal_handle-&gt;canceled(result);        RCLCPP_INFO(this-&gt;get_logger(),&quot;反馈取消，结果：%d&quot;,sum);                return ;      &#125;      rate.sleep();    &#125;    //生成最终响应结果 goal_handle-&gt;succeed()    //void succeed(std::shared_ptr&lt;base_interfaces_demo::action::Progress_Result&gt; result_msg)    if(rclcpp::ok())&#123;      result-&gt;sum = sum;      goal_handle-&gt;succeed(result);      RCLCPP_INFO(this-&gt;get_logger(),&quot;最终响应结果：%d&quot;,sum);    &#125;  &#125;  void handle_accepted(std::shared_ptr&lt;rclcpp_action::ServerGoalHandle&lt;Progress&gt;&gt; goal_handle)&#123;    //新建子线程处理耗时的主逻辑实现    std::thread(std::bind(&amp;ActionService::execute,this,goal_handle)).detach();  &#125;&#125;;int main(int argc,char **argv)&#123;  rclcpp::init(argc,argv);  rclcpp::spin(std::make_shared&lt;ActionService&gt;());    rclcpp::shutdown();  return 0;&#125;

客户端
#include &lt;rclcpp/rclcpp.hpp&gt;#include &lt;rclcpp_action/rclcpp_action.hpp&gt;#include &lt;base_interfaces_demo/action/progress.hpp&gt;using base_interfaces_demo::action::Progress;using namespace std::chrono_literals;using std::placeholders::_1;using std::placeholders::_2;class ActionClient :public rclcpp::Node&#123;public:   ActionClient() :Node(&quot;action_client&quot;)&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;Action 客户端已创建&quot;);    //rclcpp::CallbackGroup::SharedPtr group = nullptr)    client_ = rclcpp_action::create_client&lt;Progress&gt;(this,&quot;get_sum&quot;);   &#125;    void send(int num)&#123;        //1.连接到服务器        if(!client_-&gt;wait_for_action_server(10s))&#123;            RCLCPP_ERROR(this-&gt;get_logger(),&quot;服务器连接失败！&quot;);            return ;        &#125;        //2.发送请求               auto goal = Progress::Goal();        auto options = rclcpp_action::Client&lt;Progress&gt;::SendGoalOptions();        goal.num = num;         options.feedback_callback = std::bind(&amp;ActionClient::feedback_callback,this,_1,_2);        options.goal_response_callback = std::bind(&amp;ActionClient::goal_response_callback,this,_1);        options.result_callback = std::bind(&amp;ActionClient::result_callback,this,_1);        auto future = client_-&gt;async_send_goal(goal,options);    &#125;    void feedback_callback(rclcpp_action::ClientGoalHandle&lt;Progress&gt;::SharedPtr goal_handle,const std::shared_ptr&lt;const Progress::Feedback&gt; feedback)&#123;        double progress = feedback-&gt;progress;        RCLCPP_INFO(this-&gt;get_logger(),&quot;进度：%lf&quot;,progress);    &#125;        //处理关于目标值的服务端响应    void goal_response_callback(std::shared_future&lt;rclcpp_action::ClientGoalHandle&lt;Progress&gt;::SharedPtr&gt; goal_handle)&#123;        //响应成功返回指针,注意！！！        if(!goal_handle.get())&#123;            RCLCPP_INFO(this-&gt;get_logger(),&quot;请求被拒绝&quot;);        &#125;else&#123;            RCLCPP_INFO(this-&gt;get_logger(),&quot;请求成功&quot;);        &#125;    &#125;    void result_callback(const rclcpp_action::ClientGoalHandle&lt;Progress&gt;::WrappedResult &amp;result)&#123;        //result.code 状态码判断最终结果状态 状态玛封装在rclcpp_action::ResultCode::        if(result.code == rclcpp_action::ResultCode::SUCCEEDED)&#123;            RCLCPP_INFO(this-&gt;get_logger(),&quot;成功！，结果：%d&quot;,result.result-&gt;sum);        &#125;else&#123;            RCLCPP_ERROR(this-&gt;get_logger(),&quot;失败!&quot;);        &#125;    &#125;private:    rclcpp_action::Client&lt;Progress&gt;::SharedPtr client_;&#125;;int main(int argc,char **argv)&#123;    if(argc !=2 )&#123;        RCLCPP_ERROR(rclcpp::get_logger(&quot;rclcpp&quot;),&quot;请提交一个整型数据！&quot;);        return 1;    &#125;    rclcpp::init(argc,argv);    auto node = std::make_shared&lt;ActionClient&gt;();        node-&gt;send(atoi(argv[1]));    rclcpp::spin(node);    rclcpp::shutdown();    return 0;&#125;

参数通信


ros2 param list
查询参数
ros2 param get my_server wheels
查询参数值
服务端
#include &lt;rclcpp/rclcpp.hpp&gt;class MyServer :public rclcpp::Node&#123;public:  //如果允许删除参数，需要通过NodeOptions配置  MyServer() :Node(&quot;my_server&quot;,rclcpp::NodeOptions().allow_undeclared_parameters(true))&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;参数服务器已建立&quot;);  &#125;  void declare()&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;------------增-----------&quot;);    this-&gt;declare_parameter(&quot;car_type&quot;,&quot;tiger&quot;);    this-&gt;declare_parameter(&quot;width&quot;,1.5);    this-&gt;declare_parameter(&quot;wheels&quot;,5);        //set也可以，但必须rclcpp::NodeOptions().allow_undeclared_parameters(true)    this-&gt;set_parameter(rclcpp::Parameter(&quot;height&quot;,1.8));  &#125;  void get()&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;------------查-----------&quot;);    //指定    auto car = this-&gt;get_parameter(&quot;car_type&quot;);    RCLCPP_INFO(this-&gt;get_logger(),&quot;key = %s , value = %s&quot;,car.get_name().c_str(),car.as_string().c_str());    //一些    auto params = this-&gt;get_parameters(&#123;&quot;car_type&quot;,&quot;width&quot;,&quot;wheels&quot;&#125;);    for(rclcpp::Parameter n : params)&#123;      RCLCPP_INFO(this-&gt;get_logger(),&quot;key = %s , value = %s&quot;,n.get_name().c_str(),n.value_to_string().c_str());         //判断是否含有      RCLCPP_INFO(this-&gt;get_logger(),&quot;是否包含%s? %d&quot;,n.get_name().c_str(),this-&gt;has_parameter(n.get_name()));    &#125;  &#125;  void update()&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;------------改-----------&quot;);    this-&gt;set_parameter(rclcpp::Parameter(&quot;width&quot;,1.4));    RCLCPP_INFO(this-&gt;get_logger(),&quot;width = %lf&quot;,this-&gt;get_parameter(&quot;width&quot;).as_double());  &#125;  void del()&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;------------删-----------&quot;);    this-&gt;undeclare_parameter(&quot;car_type&quot;);    RCLCPP_INFO(this-&gt;get_logger(),&quot;car_type还存在吗? %d&quot;,this-&gt;has_parameter(&quot;car_type&quot;));  &#125;private:&#125;;int main(int argc,char **argv)&#123;  rclcpp::init(argc,argv);    auto node = std::make_shared&lt;MyServer&gt;();  node-&gt;declare();  node-&gt;get();  node-&gt;update();  node-&gt;del();  rclcpp::spin(node);  rclcpp::shutdown();  return 0;&#125;

客户端
#include &lt;rclcpp/rclcpp.hpp&gt;#include &lt;vector&gt;using namespace std::chrono_literals;class MyClient :public rclcpp::Node&#123;public:    MyClient() :Node(&quot;my_client&quot;)&#123;    RCLCPP_INFO(this-&gt;get_logger(),&quot;参数客户端已建立&quot;);    client_ = std::make_shared&lt;rclcpp::SyncParametersClient&gt;(this,&quot;my_server&quot;);    &#125;    bool connect_server()&#123;                while(!client_-&gt;wait_for_service(1s))&#123;                        if(!rclcpp::ok())&#123;                RCLCPP_INFO(this-&gt;get_logger(),&quot;中断!&quot;);                return false;            &#125;                        RCLCPP_INFO(this-&gt;get_logger(),&quot;连接中&quot;);                &#125;        return true;    &#125;    void get()&#123;        RCLCPP_INFO(this-&gt;get_logger(),&quot;获取&quot;);                //获取单个        std::string car_name =client_-&gt;get_parameter&lt;std::string&gt;(&quot;car_type&quot;);        double width = client_-&gt;get_parameter&lt;double&gt;(&quot;width&quot;);        RCLCPP_INFO(this-&gt;get_logger(),&quot;car_name:%s&quot;,car_name.c_str());        RCLCPP_INFO(this-&gt;get_logger(),&quot;width:%lf&quot;,width);        //获取多个        auto params = client_-&gt;get_parameters(&#123;&quot;car_type&quot;,&quot;width&quot;&#125;);        for(rclcpp::Parameter  n : params)&#123;            RCLCPP_INFO(this-&gt;get_logger(),&quot;key = %s , value = %s&quot;,n.get_name().c_str(),n.value_to_string().c_str());        &#125;        //判断是否含有_IN        RCLCPP_INFO(this-&gt;get_logger(),&quot;car_type? %d&quot;,client_-&gt;has_parameter(&quot;car_type&quot;));    &#125;     void update()&#123;        RCLCPP_INFO(this-&gt;get_logger(),&quot;修改&quot;);        client_-&gt;set_parameters(&#123;rclcpp::Parameter(&quot;car_type&quot;,&quot;pig&quot;),        rclcpp::Parameter(&quot;length&quot;,&quot;5.0&quot;)&#125;);//不存在也可以，但要保证服务端那个参数        RCLCPP_INFO(this-&gt;get_logger(),&quot;length? %d&quot;,client_-&gt;has_parameter(&quot;length&quot;));    &#125;private:    rclcpp::SyncParametersClient::SharedPtr client_;&#125;;int main(int argc,char **argv)&#123;    rclcpp::init(argc,argv);    auto note = std::make_shared&lt;MyClient&gt;();        bool flag = note-&gt;connect_server();    if(!flag == true)&#123;        return 0;    &#125;    note-&gt;get();    note-&gt;update();    note-&gt;get();    rclcpp::spin(note);    rclcpp::shutdown();    return 0;&#125;

出现乱码：C语言字符串输出不兼容
]]></content>
      <tags>
        <tag>ros2</tag>
      </tags>
  </entry>
  <entry>
    <title>software-timer</title>
    <url>/2025/software-timer/</url>
    <content><![CDATA[软件定时器和硬件定时器

硬件定时器：芯片内部的一个独立外设单元（stm32中TIM1等）。
软件定时器：基于系统时钟中断且由软件来模拟的定时器，当经过设定的Tick 时钟计数值后会触发用户定义的回调函数。软件定时器本身基本不占用CPU资源，只有在回调函数被执行时才会用到CPU。

为了启用软件定时器，需要在头文件FreeRTOSConfig.h中设置configUSE_TIMERS的值为1。
回调函数原型：
void ATimerCallback( TimerHandle_t xTimer );

xTimer是定时器句柄
回调函数代码应该尽可能地简短紧凑，并且避免调用FreeRTOS的API函数防止进入阻塞状态。

软件定时器的状态

静止状态(Dormant)：处于静止装态的定时器不会执行回调函数，可以通过调用定时器的句柄启用
运行状态(Running)：处于运行状态的定时器会在设定的时间间隔（相对于定时器进入运行状态后）到达后调用回调函数。

软件定时器类型

一次性定时器(One-shot timer)：启动后只会执行一次回调函数。


一次性定时器会在执行回调函数后进入静止状态



自动重载定时器(Auto-reload timer)：周期性执行回调函数。


自动重载定时器会在执行回调函数后重新进入运行状态


软件定时器实质
软件定时器是由一个系统内核调度器自动生成的时间服务任务(Timer Server Task)来管理。当创建并启动一个软件定时器时，定时器对象会被加入到时间服务任务管理的定时器列表里。时间服务任务会周期性检查这些定时器是否到期，到期则调用你注册的回调函数。
在FreeRTOSConfig.h中相关配置

configTIMER_TASK_PRIORITY：决定了时间服务任务的运行优先级。优先级越高，定时器到期后回调就能更快被执行。
configTIMER_TASK_STACK_DEPTH：决定了时间服务任务的栈大小（单位通常是字节或“栈深度”）。

避免在回调函数中调用会阻塞的FreeRTOS api，会阻塞时间服务任务，导致其他定时器无法及时处理，严重时影响系统定时精度甚至死锁。
软件定时器的启动、停止、重置等操作，并不是立即生效，而是通过“命令队列”发送到时间服务任务中去处理。
这个队列的长度由configTIMER_QUEUE_LENGTH决定。
图形化配置界面

Callback选项是由用户实现的回调函数，Type选项可以选择一次性定时器或者自动重载定时器。
FreeRTOS 定时器相关 API 函数说明

创建定时器

TimerHandle_t xTimerCreate( const char * const pcTimerName,                           TickType_t xTimerPeriodInTicks,                           UBaseType_t uxAutoReload,                           void * pvTimerID,                           TimerCallbackFunction_t pxCallbackFunction )

功能：创建定时器。
参数说明：

pcTimerName：定时器的名称，仅用于调试。
xTimerPeriodInTicks：定时器的周期（以tick为单位），可用pdMS_TO_TICKS()宏将毫秒转换为tick。
uxAutoReload：设为pdTRUE时为自动重载定时器，pdFALSE为一次性定时器。
pvTimerID：定时器的ID，可用于用户自定义目的。
pxCallbackFunction：定时器到期时执行的回调函数。


返回值：

非NULL表示创建成功；
NULL表示创建失败。




启动定时器

BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait )

功能：启动定时器。
参数说明：

xTimer：要启动的定时器句柄。
xTicksToWait：如果命令队列已满，最多等待多少tick。


返回值：

pdPASS表示启动成功；
pdFALSE表示失败。




设置定时器ID

void vTimerSetTimerID( const TimerHandle_t xTimer, void *pvNewID )

功能：设置定时器的pvTimerID属性。
参数说明：

xTimer：定时器句柄。
pvNewID：要设置的新ID值。




获取定时器ID

void *pvTimerGetTimerID( TimerHandle_t xTimer )

功能：获取定时器的pvTimerID属性。
参数说明：

xTimer：定时器句柄。


返回值：pvTimerID的值。


改变定时器周期

BaseType_t xTimerChangePeriod( TimerHandle_t xTimer,                               TickType_t xNewTimerPeriodInTicks,                              TickType_t xTicksToWait )

功能：改变定时器的运行周期。
参数说明：

xTimer：定时器句柄。
xNewTimerPeriodInTicks：新的定时器周期（tick），可用pdMS_TO_TICKS()转换。
xTicksToWait：如果命令队列已满，最多等待多少tick。


返回值：

pdPASS表示成功；
pdFALSE表示失败。




重置定时器

BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait )

功能：重置定时器，重新开始计时。
参数说明：

xTimer：定时器句柄。
xTicksToWait：如果命令队列已满，最多等待多少tick。


返回值：

pdPASS表示成功；
pdFALSE表示失败。



定时器ID作用

多个定时器共用同一个回调函数时，可以通过ID判断当前是哪个定时器触发
pvTimerID 是一个 void* 指针，可以指向任何类型的数据结构，如整型、结构体、数组等。可以在回调函数里获得上下文信息（如相关任务句柄、设备句柄、状态数据等）

void vTimerCallback(TimerHandle_t xTimer)&#123;void *pvID = pvTimerGetTimerID(xTimer);// 根据ID做不同的操作&#125;
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>task-management</title>
    <url>/2025/task-management/</url>
    <content><![CDATA[freertos任务管理

任务
在FreeRTOS中，线程（Thread）和任务（Task）的概念是相同的。每个任务就是一个线程，有着自己的一个程序。
void TaskFunction( void *pvParameters )&#123;  int32_t test = 10;   for(;;)  &#123;  &#125;  vTaskDelete(NULL);  &#125;

任务函数不能有返回值，即使用return语句。
不需要任务时必须显示删除任务，如调用vTaskDelete()函数。
每个任务都有自己的栈区和优先级。

任务的状态

就绪状态（Ready）

任务已准备好运行，但尚未被调度器选中执行
可能有多个任务同时处于就绪态
形成就绪列表，调度器从中选择最高优先级任务运行


运行状态（Running）

当前正在处理器上执行的任务
单核系统中任何时刻只能有一个任务处于运行态
由调度器选择优先级最高的就绪任务进入


阻塞状态（Blocked）

任务暂时不能执行，等待某个事件或超时
有明确的超时时间或等待条件
不参与调度器的任务选择


挂起状态（Suspended）

任务被明确挂起，不参与调度
没有超时机制，必须由其他任务或中断显示恢复
用于长期停止任务执行

  // 挂起任务示例vTaskSuspend(xTaskHandle); // 将任务挂起// ...其他代码vTaskResume(xTaskHandle);  // 将任务从挂起态恢复


freertos任务状态转换

cmsis rtos 接口

任务优先级
可以通过vTaskPrioritySet()设置。
FreeRTOSConfig.h头文件中的configMAX_PRIORITIES可以设置最高优先级的值。0最低，configMAX_PRIORITIES-1最高。
configMAX_PRIORITIES受configUSE_PORT_OPTIMISED_TASK_SELECTION参数值影响。


当configUSE_PORT_OPTIMISED_TASK_SELECTION值设为0时，代表通用方式。configMAX_PRIORITIES最大值不受限制。

但不建议设置太高，会增加RAM占用,程序最坏运行时间更长。

原因：freertos调度器通过为每个优先级维护独立的任务就绪列表来工作,就绪列表通常存储在一个数组中：List_t pxReadyTasksLists[ configMAX_PRIORITIES ]：
&gt;优先级0 → 就绪列表0 → [任务A] → [任务B]&gt;优先级1 → 就绪列表1 → [任务C]&gt;优先级2 → 就绪列表2 → [任务D] → [任务E] → [任务F]&gt;优先级N → 就绪列表N → [空]   





当configUSE_PORT_OPTIMISED_TASK_SELECTION值设为1时，代表架构优化方式。架构优化方式采用了平台相关的汇编代码，比通用方式更快，configMAX_PRIORITIES的值不会影响程序的最坏运行时间。在这种方式下，configMAX_PRIORITIES的最大值不能超过32。因为是平台相关，不是所有的单片机支持这个方式。


任务创建
使用xTaskCreate()函数创建。
BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,                        const char * const pcName,                        uint16_t usStackDepth,                        void *pvParameters,                        UBaseType_t uxPriority,                        TaskHandle_t *pxCreatedTask );

pvTaskCode:函数指针，指向执行任务的函数
pcName:任务描述名称，方便调试，不需要设为NULL
usStackDepth:栈空间大小，单位是字（word）（Cortex-M通常为4字节一字）
pvParameters:传递给任务的参数指针，不需要设为NULL
uxPriority:设置任务优先级，0~configMAX_PRIORITIES-1
pxCreatedTask:指向任务句柄的指针，通过句柄对任务进行设置，如改变优先级，任务状态，不需要设为NULL
函数返回值：成功返回pdPass(1),失败返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(-1)



CMSIS RTOS api 使用osThreadNew()函数创建任务，其封装了xTaskCreate()函数

调度器
调度器（scheduler）简单来说是一个决定哪个任务应该执行的算法代码。在FreeRTOS中采用了round-robin的调度算法，包含抢占式（preemptive）和合作式（cooperative）两种模式。模式的选择在FreeRTOSConfig.h头文件中由configUSE_PREEMPTION这个参数决定，为1时是抢占式模式，为0时是合作式模式。

抢占式

在抢占式模式下，在每次调度器运行时，高优先级的任务会被切换优先执行，当前处于运行状态的低优先级的任务则会立刻进入就绪状态等待运行，如下图所示，高优先级的Task2抢占了Task1。如果几个任务的优先级一样的话，它们就会轮流执行共享CPU资源。



合作式

在合作式模式下，高优先级任务不会抢占当前正在运行状态的低优先级任务，直到低优先级任务完成进入阻塞状态（比如调用osDelay()函数）或就绪状态（比如调用osThreadYield()函数）或者被系统置于挂起状态后才会切换任务，如下图所示。




Stm32CubeMX中，USE_PREEMPTION为Eabled时采用抢占式，Disabled为合作式

任务调度
FreeRTOS对任务的调度采用基于时间片（time slicing）的方式。时间片，顾名思义，把一段时间等分成了很多个时间段，在每一个时间段保证优先级最高的任务能执行，同时如果几个任务拥有相等的优先级，则它们会轮流使用每个时间段占用CPU资源。调度器会在每个时间片结束的时候通过周期中断（tick interrupt）执行一次，调度器根据设置的抢占式还是合作式模式选择哪个任务在下一个时间片会运行。
时间片的大小由configTICK_RATE_HZ这个参数设置。如果configTICK_RATE_HZ设置为10HZ，则时间片的大小为100ms。configTICK_RATE_HZ的值由应用需求决定，通常设为100HZ（时间片大小相应为10ms）。


在上图任务调度的演示中，Kernel表示系统内核即调度程序，Task1和Task2是两个优先级相同的任务。t1到t2是一个时间片，t2到t3是另一个时间片。在每一个时间片快结束的时候，调度程序通过周期中断（tick interrupt）被调用并选择在下一个时间片要执行的任务（红色部分代表调度程序Kernel在运行）。此时因为两个任务的优先级相同，调度程序会让两个任务轮流占用时间片进行运行（蓝色部分代表Task1在运行，绿色部分代表Task2在运行）

可以把FreeRTOS当成一个时间离散的系统（时间并不是连续的），时间的最小单位是一个节拍（tick），延时函数 vTaskDelayUntil和vTaskDelay的参数需要的是延时的节拍数，不能直接设置延时时间，因此使用 pdMS_TO_TICKS 函数将时间转换为节拍数。通过pdMS_TO_TICKS这个函数可以把时间转换成节拍数（一个节拍代表一个时间片），并且调用这个函数可以保证即使configTICK_RATE_HZ的值不同时时间是一致的。

抢占式时间片调度

内核调度器在每个时间片结束的时候执行一次，选择处于就绪状态的任务中优先级最高的任务置于下一个时间片执行。如果优先级相同的话则交替执行。此时，FreeRTOSConfig.h头文件的设置如下：
configUSE_PREEMPTION（允许抢占） 1
configUSE_TIME_SLICING（采用时间片） 1



抢占式无时间片调度

这种调度方式下，因为没有采取时间片，所以调度器的执行开销会比较小。如果两个任务的优先级相同的话，在抢占式时间片调度下，两个任务会交替运行；在抢占式无时间片调度下，当前运行的任务会一直运行，直到它进入阻塞或者挂起状态，另一个相同优先级的任务才会运行。高优先级的任务会抢占低优先任务。此时，FreeRTOSConfig.h头文件的设置如下：
configUSE_PREEMPTION（允许抢占） 1
configUSE_TIME_SLICING（采用时间片） 0



合作式调度

空闲任务(Idle Task)
vTaskStartScheduler()函数用来启动调度器。空闲任务是调用器启动后自动创建的一个任务。
FreeRTOS的设计原则是：调度器必须永远有一个可以运行的任务。即使所有用户任务都在等待事件（比如等待一个信号量、一个队列消息或者一个延时到期），系统也必须有事可做。
空闲任务就是为了保证始终至少有一个任务处于就绪（Ready）状态而存在的。
空闲任务特点:

优先级为0,最低的优先级确保空闲任务不会抢占用户任务。当用户创建的任务都在阻塞或者挂起状态时，空闲任务才执行。
负责清理内核资源，当有任务被删除后，确保空闲任务能运行清理和回收内核资源。

同时，空闲任务可以绑定一个钩子任务（Task Hook），当空闲任务运行的时候钩子任务也会被自动调用。钩子任务里可以添加测量空闲任务运行时间的函数或者把系统放入低功耗模式的函数。空闲任务运行的时间反映出了系统的可用计算资源，可以用于推算CPU的占用率。CPU的占用率过高的话可能会对系统的实时性有影响。
钩子任务的函数原型是vApplicationIdleHook( void );
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
</search>

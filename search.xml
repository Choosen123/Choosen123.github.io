<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2025/09/07/freertos/heap-and-stack/heap-and-stack/</url>
    <content><![CDATA[
title: FreeRTOS堆栈管理date: 2025-09-07tags:  - FreeRTOS  - 嵌入式categories:  - FreeRTOSfreertos堆栈注意堆栈空间分配方向相反，若两区域相互覆盖会出现无法预料的问题。
任务如何分配空间当调用创建任务api函数xTaskCreate()时，freertos会在堆中开辟出一片空间，用于存放任务控制信息TCB块和用于存储任务相关变量的栈区Stack。  
使用xTaskCreateStatic()在静态区创建任务
TCB的大小构成TCB信息包括：任务当前执行到哪里了（程序计数器、堆栈指针）、任务的状态（运行、就绪、阻塞、挂起）、任务的优先级、任务的名字、任务等待的事件（比如信号量、队列、通知）等等。
TCB的大小构成取决于FreeRTOSConfig.h头文件的设置，启用了哪些功能

最小设置下96字节
configUSE_TASK_NOTIFICATIONS是1，增加8字节
configUSE_TRACE_FACILITY是1，增加8字节
configUSE_MUTEXES是1,增加8字节




参数
含义
目的



configUSE_TASK_NOTIFICATIONS
启用任务通知
轻量级任务间通信&#x2F;同步,一个任务可以给另一个任务“发通知”（设置通知值&#x2F;状态），另一个任务可以“等待通知”（阻塞直到收到通知


configUSE_TRACE_FACILITY
启用跟踪调试设施
系统调试分析（任务状态、事件）


configUSE_MUTEXES
启用互斥锁
启用互斥锁


MSP和PSP栈指针MSP主堆栈指针(Main stack pointer):

系统启动时默认使用的堆栈指针
用于处理中断和异常
操作系统内核(如FreeRTOS内核)使用

PSP进程堆栈指针(Process stack pointer)

用于每个任务独立的栈指针
每个FreeRTOS任务都有自己的PSP堆栈

 
示例：

系统启动：使用MSP初始化所有硬件和FreeRTOS

任务切换：

LED任务使用自己的PSP，包含其局部变量ledState
温度任务使用自己的PSP，包含局部变量temperature和数组samples
任务切换时，FreeRTOS保存当前PSP和恢复下一个任务的PSP


中断处理：

当按键中断发生时，无论哪个任务在运行，处理器立即切换到MSP
中断处理完毕后，返回到被中断的任务（使用其PSP）或切换到更高优先级的任务



内存池分配内存池分配是指在程序编译阶段就分配一定数量的内存块留作备用。当有新的内存需求时，就从内存块分出一部分内存块，若内存块不够了就继续申请新的内存。
当FreeRTOS需要RAM的时候，它会调用pvPortMalloc这个函数而不是Malloc这个系统函数；当它需要释放内存的时候，会调用vPortFree这个函数而不是free这个系统函数。各提供了5种实现方案(heap_1.c,heap_2.c,heap_3.c,heap_4.c,heap_5.c),同时支持定制。stm32cubemx默认采用4。
heap_1适用于小型嵌入式系统。且只能在调度器启动之前创建任务和其他内核对象。内存只需要在程序启动调度器前采用first fit算法对内存进行动态分配，之后任务的内存分配在程序的运行周期中保持不变并且无法被释放。确定性的，不会导致内存碎片化,执行时间固定。使用静态数组作为堆内存。数组大小由FreeRTOSConfig.h文件中ConfigTOTAL_HEAP_SIZE定义。  
xTaskCreate(myTask, &quot;Task1&quot;, 100, NULL, 1, NULL);xQueueCreate(10, sizeof(uint32_t));

 
heap_2(不推荐使用？)内存管理也由一个数组实现，大小由FreeRTOSConfig.h文件中configTOTAL_HEAP_SIZE定义使用best fit算法对内存进行动态分配，允许释放内存。对大的内存块进行分割，但无法合并相连的内存块，容易导致内存的碎片化。
void *buffer = pvPortMalloc(50);  // 分配50字节// 使用内存...vPortFree(buffer);  // 释放内存


heap_3使用标准C库的malloc() free()函数添加了互斥锁使其线程安全，调用malloc函数和free函数的时候会临时挂起FreeRTOS的调度器。
// 和标准C库函数名相同，但内部添加了互斥保护void *data = malloc(100);free(data);


heap_4内存可以自由分配和合并空闲的内存块，并使得整体的性能最优。使用”首次匹配”算法（使用第一个足够大的空闲块）Heap_4的分配方案所需要时间是不确定性的，但速度要比malloc和free函数快。
// 频繁分配释放也不会导致严重的内存碎片for(int i=0; i&lt;1000; i++) &#123;    void *temp = pvPortMalloc(random_size());    // 使用内存...    vPortFree(temp);&#125;

 
heap_5类似于Heap_4的内存分配技术，但不同于Heap_4只用一个连续的数组表示堆，Heap_5可以用不同的数组空间对内存进行分配。要使用vPortDefineHeapRegions这个函数对不同的数组进行申明。
// 初始化多区域内存// 添加内部SRAM区域HeapRegion_t xHeapRegions[] = &#123;    &#123; (uint8_t*)0x20000000, 0x10000 &#125;,  // 内部SRAM: 64KB    &#123; (uint8_t*)0x60000000, 0x80000 &#125;,  // 外部SRAM: 512KB    &#123; NULL, 0 &#125;  // 终止标记&#125;;vPortDefineHeapRegions(xHeapRegions);// 之后正常使用void *buffer = pvPortMalloc(1000);


内存管理相关函数size_t xPortGetFreeHeapSize( void );这个函数会返回当前堆中的空闲空间大小（单位是字节），可以用来优化堆空间大小。比如在系统运行起来后调用xPortGetFreeHeapSize如果返回了3000字节，就可以把堆大小configTOTAL_HEAP_SIZE设置为3000字节多一点。
size_t xPortGetMinimumEverFreeHeapSize( void );这个函数会返回在系统运行过程中堆空间的最小空闲空间，如果最小空闲空间很小的话可以考虑提高堆大小configTOTAL_HEAP_SIZE的值。这个函数只能在Heap_4或者Heap_5下调用。  
void vApplicationMallocFailedHook( void );这是一个回调函数，需要用户自己实现。如果配置文件中configUSE_MALLOC_FAILED_HOOK 设置为1的话，当堆分配内存失败时会调用此函数。用户可以在此函数中进行错误处理。
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/09/07/freertos/interrupt-management/interrupt-management/</url>
    <content><![CDATA[中断注意事项在FreeRTOS中，任务程序由内核调度器统一调度和执行，程序的运行情况在一定程度上是稳定可预测的；中断相对而言是由外部环境决定是不可预测的，会对系统引入不确定性，如果使用不当的话会导致系统的失效和不稳定。对中断的使用要根据实际需求和使用场景来决定，通过合理的配置和与FreeRTOS的中断管理（Interrupt Management）配合可以达到系统的高效能和高稳定性。  
FreeRTOS中断管理在FreeRTOS中中断的优先级和任务的优先级是有区别的,中断拥有更高的权限。  

任务的优先级是由用户设置内核管理器管理的软件特性（software feature），与操作系统所在的硬件平台无关。  
中断的优先级是由硬件平台相关的硬件特性（hardware feature），在中断代码运行的时候任务的代码将无法运行。即使是拥有最小优先级的中断也会打断拥有最高优先级的任务。FreeRTOS对于一些系统API函数提供两种版本，一种是供任务调用的，一种是供中断调用的（Interrupt Safe API）。由中断调用的API函数后缀上会有“FromISR”。

当在普通任务中调用FreeRTOS的API函数（如xQueueSend()、xSemaphoreGive()等）时：如果configUSE_PREEMPTION设置为1（抢占式调度）,并且调用API后有更高优先级的任务变为就绪状态,调度器会自动立即切换到那个更高优先级的任务。  
当在中断处理时调用特殊的”FromISR”版本的API（如xQueueSendFromISR()、xSemaphoreGiveFromISR()等），如果有更高级别的任务进入就绪态，系统不会在中断处理函数结束后自动切换任务。而是需要手动根据”FromISR”版本函数的一个自带参数pxHigherPriorityTaskWoken参数的值，调用portTIELD_FROM_ISR(pxHigherPriorityTaskWoken)来手动决定是否切换任务。

如果API的调用导致更高级别任务进入就绪态，pxHigherPriorityTaskWoken参数会被设为pdTRUE

// 中断处理函数void vUARTInterruptHandler(void)&#123;    BaseType_t xHigherPriorityTaskWoken = pdFALSE;    char receivedChar;        // 假设收到一个字符    receivedChar = UART_READ_REGISTER;        // 将字符发送到队列，可能会唤醒等待队列的高优先级任务    xQueueSendFromISR(xCharQueue, &amp;receivedChar, &amp;xHigherPriorityTaskWoken);        // 中断结束前，检查是否需要任务切换    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);&#125;

延迟中断处理延迟中断处理是一种设计模式：  

最小化的中断服务程序(ISR)：只做必要的紧急处理  
专门的高优先级任务：处理剩余的中断相关工作

优点：

缩短中断响应时间：ISR应尽可能短，减少中断禁用时间
提高系统响应性：复杂处理放在任务中，不阻塞其他中断
简化代码：在任务中可以使用所有FreeRTOS API，而不仅限于FromISR版本
优先级控制：通过任务优先级控制中断处理的优先顺序
便于调试：任务比ISR更容易调试

// 中断服务程序 - 硬件直接调用void InterruptHandling()&#123;   RecordInterrupt();     // 记录中断信息（可能存储到全局变量或队列）   ClearInterruptFlag();  // 清除中断标志，允许新的中断发生   portYIELD_FROM_ISR(pdTRUE); // 强制任务切换，让高优先级任务立即执行&#125;// 中断处理任务 - 由调度器调度void vInterruptHandling(void const * argument)&#123;   // 无限循环，等待中断发生   for(;;) &#123;       ProcessInterrupt(); // 处理之前记录的中断信息   &#125;&#125;

工作流程：

硬件中断触发，进入InterruptHandling()函数
ISR只做简单的记录和清除标志工作
ISR调用portYIELD_FROM_ISR(pdTRUE)强制任务切换
调度器选择最高优先级的就绪任务
如果中断处理任务vInterruptHandling()是最高优先级，它会立即执行
中断处理任务分析并处理中断数据

一般还会搭配信号量，队列等机制来避免一直处于高优先级就绪态，阻塞其他任务执行。
void vInterruptHandlingTask(void *pvParameters)&#123;    for(;;) &#123;        // 等待中断通知，这里任务进入阻塞态        // 只有当接收到通知时，任务才会变为就绪态        if(xSemaphoreTake(xInterruptSemaphore, portMAX_DELAY) == pdTRUE) &#123;                        // 处理中断相关的工作            ProcessInterrupt();                        // 处理完成后，循环回到开头，再次尝试获取信号量            // 如果没有新的中断发生，任务会再次阻塞在这里        &#125;    &#125;&#125;
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/09/07/freertos/queue-management/queue-management/</url>
    <content><![CDATA[进程间通信方式 

a图采用进程间共享内存,共用和交互数据更快
b图采用消息队列，更通用更稳定全局变量不太线程安全TaskA和B之间通过队列交互数据，A写B读。

队列的实现方式
复制队列(Queue by copy)：写入队列的数据每个字节都被完整复制到队列中。
引用队列(Queue by reference):写入队列的是数据的引用或指针。

FreeRTOS采用复制队列。优势如下：

有些储存在栈上的变量在函数运行结束后是将会被销毁的，如果采用引用队列的话引用会失效
发送数据的任务可以重复使用变量，采用引用队列的话每发送一个数据需要一个新的变量
发送队列数据的任务和接受队列数据的任务之间是没有耦合的，两者互相不影响
复制队列可以通过储存指向数据块的指针实现引用队列的功能

一个队列可以有对个写入数据的任务和多个读取数据的任务。阻塞时间(block time)：当队列数据为空时，任务处于阻塞状态的时间。当任务尝试读取队列数据时，可以设置一个阻塞时间(xQueueReceive())。 当有数据在队列或到达阻塞时间时，任务进入就绪状态。如果有多个任务同时在阻塞状态等待队列数据，优先级高的任务会在数据到达时进入就绪状态；在优先级相同的时候，等待时间长的任务会进入就绪状态。同理可得多个任务写入队列的情景。同时，FreeRTOS 允许任务使用队列集同时等待多个队列，当队列集中的任何一个队列收到数据时，任务可以被唤醒。
常见APIFreeRTOS API
创建队列

QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )

返回值是QueueHandle_t具柄类型，表示的是对所创建队列的一个引用句柄。FreeRTOS从FreeRTOS的堆中指定一些内存空间给队列使用。如果堆中没有足够空间给队列使用的话函数的返回值会是NULL
uxQueueLength：队列包含数据的最大长度
uxItemSize：每个数据占用的字节大小


发送数据

  BaseType_t xQueueSend( QueueHandle_t xQueue, const void * pvItemToQueue,TickType_t xTicksToWait )
xQueueSend（）函数用于将数据发送到队列（具体一点就是队列的尾部）。如果要在中断程序调用的话需要使用xQueueSendFromISR（）函数（只能在中断函数中使用）。

xQueue 队列的具柄，来自于xQueueCreate（）的返回值  
pvItemToQueue 所发送数据的引用，然后这些数据会被复制到队列中  
xTicksToWait 队列如果满时发送任务的阻塞时间（block time），上文已经介绍过，可以通过pdMS_TO_TICKS()把时间转换成节拍数。如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中INCLUDE_vTaskSuspend参数设置为1）返回值 发送数据成功时返回pdPASS，失败时返回errQUEUE_FULL

BaseType_t xQueueSendToFront( QueueHandle_t xQueue, const void * pvItemToQueue,TickType_t xTicksToWait )BaseType_t xQueueSendToBack( QueueHandle_t xQueue, const void * pvItemToQueue,TickType_t xTicksToWait )
可选择发送到队列开头还是结尾，xQueueSendToBack本质和xQueueSend是一样的。  

接收数据

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer,TickType_t xTicksToWait )
xQueueReceive用于从队列里读取数据，同时读取到的数据会被从队列中移除。

xQueue 队列的具柄，来自于xQueueCreate（）的返回值  
pvBuffer 指向内存空间的一个引用，读取的数据会被复制到这片内存  
xTicksToWait 队列如果空时接送任务的阻塞时间（block time），如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中INCLUDE_vTaskSuspend参数设置为1）

返回值 接收数据成功时返回pdPASS，失败时返回errQUEUE_EMPTY

查询队列数据数量

UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue )


查看数据

    BaseType_t xQueuePeek(QueueHandle_t xQueue,void *pvBuffer,TickType_t xTicksToWait);
查看队列前面的数据项，但不会将其移除。中断中使用xQueuePeekFromISR  

xQueue：要读取的队列句柄。
pvBuffer：指向用于存储队列项的缓冲区的指针。
xTicksToWait：如果队列为空，任务等待的最大时间（tick 数）；如果为 0，则立即返回。返回值 成功读取pdTRUE，没读到返回pdFALSE。

CMSIS RTOS API 
图形化配置Item Size可以换成用户自定义的结构体类型。
CMSIS中邮件队列引用队列的实现，叫做邮件队列（mail queue），传递的是储存数据块的地址指针。 
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/09/07/freertos/software-timer/software-timer/</url>
    <content><![CDATA[软件定时器和硬件定时器
硬件定时器：芯片内部的一个独立外设单元（stm32中TIM1等）。
软件定时器：基于系统时钟中断且由软件来模拟的定时器，当经过设定的Tick 时钟计数值后会触发用户定义的回调函数。软件定时器本身基本不占用CPU资源，只有在回调函数被执行时才会用到CPU。

为了启用软件定时器，需要在头文件FreeRTOSConfig.h中设置configUSE_TIMERS的值为1。
回调函数原型：
void ATimerCallback( TimerHandle_t xTimer );

xTimer是定时器句柄  
回调函数代码应该尽可能地简短紧凑，并且避免调用FreeRTOS的API函数防止进入阻塞状态。

软件定时器的状态
静止状态(Dormant)：处于静止装态的定时器不会执行回调函数，可以通过调用定时器的句柄启用
运行状态(Running)：处于运行状态的定时器会在设定的时间间隔（相对于定时器进入运行状态后）到达后调用回调函数。

软件定时器类型
一次性定时器(One-shot timer)：启动后只会执行一次回调函数。


一次性定时器会在执行回调函数后进入静止状态


自动重载定时器(Auto-reload timer)：周期性执行回调函数。


自动重载定时器会在执行回调函数后重新进入运行状态

软件定时器实质软件定时器是由一个系统内核调度器自动生成的时间服务任务(Timer Server Task)来管理。当创建并启动一个软件定时器时，定时器对象会被加入到时间服务任务管理的定时器列表里。时间服务任务会周期性检查这些定时器是否到期，到期则调用你注册的回调函数。在FreeRTOSConfig.h中相关配置  

configTIMER_TASK_PRIORITY：决定了时间服务任务的运行优先级。优先级越高，定时器到期后回调就能更快被执行。
configTIMER_TASK_STACK_DEPTH：决定了时间服务任务的栈大小（单位通常是字节或“栈深度”）。

避免在回调函数中调用会阻塞的FreeRTOS api，会阻塞时间服务任务，导致其他定时器无法及时处理，严重时影响系统定时精度甚至死锁。  
软件定时器的启动、停止、重置等操作，并不是立即生效，而是通过“命令队列”发送到时间服务任务中去处理。这个队列的长度由configTIMER_QUEUE_LENGTH决定。
图形化配置界面Callback选项是由用户实现的回调函数，Type选项可以选择一次性定时器或者自动重载定时器。
FreeRTOS 定时器相关 API 函数说明
创建定时器

TimerHandle_t xTimerCreate( const char * const pcTimerName,                           TickType_t xTimerPeriodInTicks,                           UBaseType_t uxAutoReload,                           void * pvTimerID,                           TimerCallbackFunction_t pxCallbackFunction )


功能：创建定时器。
参数说明：
pcTimerName：定时器的名称，仅用于调试。
xTimerPeriodInTicks：定时器的周期（以tick为单位），可用pdMS_TO_TICKS()宏将毫秒转换为tick。
uxAutoReload：设为pdTRUE时为自动重载定时器，pdFALSE为一次性定时器。
pvTimerID：定时器的ID，可用于用户自定义目的。
pxCallbackFunction：定时器到期时执行的回调函数。


返回值：
非NULL表示创建成功；
NULL表示创建失败。




启动定时器

BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait )


功能：启动定时器。
参数说明：
xTimer：要启动的定时器句柄。
xTicksToWait：如果命令队列已满，最多等待多少tick。


返回值：
pdPASS表示启动成功；
pdFALSE表示失败。




设置定时器ID

void vTimerSetTimerID( const TimerHandle_t xTimer, void *pvNewID )


功能：设置定时器的pvTimerID属性。
参数说明：
xTimer：定时器句柄。
pvNewID：要设置的新ID值。




获取定时器ID

void *pvTimerGetTimerID( TimerHandle_t xTimer )

功能：获取定时器的pvTimerID属性。
参数说明：
xTimer：定时器句柄。


返回值：pvTimerID的值。


改变定时器周期

BaseType_t xTimerChangePeriod( TimerHandle_t xTimer,                               TickType_t xNewTimerPeriodInTicks,                              TickType_t xTicksToWait )


功能：改变定时器的运行周期。
参数说明：
xTimer：定时器句柄。
xNewTimerPeriodInTicks：新的定时器周期（tick），可用pdMS_TO_TICKS()转换。
xTicksToWait：如果命令队列已满，最多等待多少tick。


返回值：
pdPASS表示成功；
pdFALSE表示失败。




重置定时器

BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait )

功能：重置定时器，重新开始计时。
参数说明：
xTimer：定时器句柄。
xTicksToWait：如果命令队列已满，最多等待多少tick。


返回值：
pdPASS表示成功；
pdFALSE表示失败。



定时器ID作用
多个定时器共用同一个回调函数时，可以通过ID判断当前是哪个定时器触发  
pvTimerID 是一个 void* 指针，可以指向任何类型的数据结构，如整型、结构体、数组等。可以在回调函数里获得上下文信息（如相关任务句柄、设备句柄、状态数据等）

void vTimerCallback(TimerHandle_t xTimer)&#123;void *pvID = pvTimerGetTimerID(xTimer);// 根据ID做不同的操作&#125;

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/09/07/freertos/task-management/task-management/</url>
    <content><![CDATA[freertos任务管理
任务在FreeRTOS中，线程（Thread）和任务（Task）的概念是相同的。每个任务就是一个线程，有着自己的一个程序。  
void TaskFunction( void *pvParameters )&#123;  int32_t test = 10;   for(;;)  &#123;  &#125;  vTaskDelete(NULL);  &#125;

任务函数不能有返回值，即使用return语句。
不需要任务时必须显示删除任务，如调用vTaskDelete()函数。
每个任务都有自己的栈区和优先级。

任务的状态
就绪状态（Ready）
任务已准备好运行，但尚未被调度器选中执行
可能有多个任务同时处于就绪态
形成就绪列表，调度器从中选择最高优先级任务运行


运行状态（Running）
当前正在处理器上执行的任务
单核系统中任何时刻只能有一个任务处于运行态
由调度器选择优先级最高的就绪任务进入


阻塞状态（Blocked）
任务暂时不能执行，等待某个事件或超时
有明确的超时时间或等待条件
不参与调度器的任务选择


挂起状态（Suspended）
任务被明确挂起，不参与调度 
没有超时机制，必须由其他任务或中断显示恢复
用于长期停止任务执行

  // 挂起任务示例vTaskSuspend(xTaskHandle); // 将任务挂起// ...其他代码vTaskResume(xTaskHandle);  // 将任务从挂起态恢复

freertos任务状态转换 
cmsis rtos 接口 
任务优先级可以通过vTaskPrioritySet()设置。FreeRTOSConfig.h头文件中的configMAX_PRIORITIES可以设置最高优先级的值。0最低，configMAX_PRIORITIES-1最高。
configMAX_PRIORITIES受configUSE_PORT_OPTIMISED_TASK_SELECTION参数值影响。

当configUSE_PORT_OPTIMISED_TASK_SELECTION值设为0时，代表通用方式。configMAX_PRIORITIES最大值不受限制。

但不建议设置太高，会增加RAM占用,程序最坏运行时间更长。
原因：freertos调度器通过为每个优先级维护独立的任务就绪列表来工作,就绪列表通常存储在一个数组中：List_t pxReadyTasksLists[ configMAX_PRIORITIES ]：
&gt;优先级0 → 就绪列表0 → [任务A] → [任务B]&gt;优先级1 → 就绪列表1 → [任务C]&gt;优先级2 → 就绪列表2 → [任务D] → [任务E] → [任务F]&gt;优先级N → 就绪列表N → [空]   



当configUSE_PORT_OPTIMISED_TASK_SELECTION值设为1时，代表架构优化方式。架构优化方式采用了平台相关的汇编代码，比通用方式更快，configMAX_PRIORITIES的值不会影响程序的最坏运行时间。在这种方式下，configMAX_PRIORITIES的最大值不能超过32。因为是平台相关，不是所有的单片机支持这个方式。


任务创建使用xTaskCreate()函数创建。
BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,                        const char * const pcName,                        uint16_t usStackDepth,                        void *pvParameters,                        UBaseType_t uxPriority,                        TaskHandle_t *pxCreatedTask );


pvTaskCode:函数指针，指向执行任务的函数
pcName:任务描述名称，方便调试，不需要设为NULL
usStackDepth:栈空间大小，单位是字（word）（Cortex-M通常为4字节一字）
pvParameters:传递给任务的参数指针，不需要设为NULL
uxPriority:设置任务优先级，0~configMAX_PRIORITIES-1 
pxCreatedTask:指向任务句柄的指针，通过句柄对任务进行设置，如改变优先级，任务状态，不需要设为NULL
函数返回值：成功返回pdPass(1),失败返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(-1)

 

CMSIS RTOS api 使用osThreadNew()函数创建任务，其封装了xTaskCreate()函数

调度器调度器（scheduler）简单来说是一个决定哪个任务应该执行的算法代码。在FreeRTOS中采用了round-robin的调度算法，包含抢占式（preemptive）和合作式（cooperative）两种模式。模式的选择在FreeRTOSConfig.h头文件中由configUSE_PREEMPTION这个参数决定，为1时是抢占式模式，为0时是合作式模式。  

抢占式 
在抢占式模式下，在每次调度器运行时，高优先级的任务会被切换优先执行，当前处于运行状态的低优先级的任务则会立刻进入就绪状态等待运行，如下图所示，高优先级的Task2抢占了Task1。如果几个任务的优先级一样的话，它们就会轮流执行共享CPU资源。 


合作式 
在合作式模式下，高优先级任务不会抢占当前正在运行状态的低优先级任务，直到低优先级任务完成进入阻塞状态（比如调用osDelay()函数）或就绪状态（比如调用osThreadYield()函数）或者被系统置于挂起状态后才会切换任务，如下图所示。



Stm32CubeMX中，USE_PREEMPTION为Eabled时采用抢占式，Disabled为合作式 
任务调度FreeRTOS对任务的调度采用基于时间片（time slicing）的方式。时间片，顾名思义，把一段时间等分成了很多个时间段，在每一个时间段保证优先级最高的任务能执行，同时如果几个任务拥有相等的优先级，则它们会轮流使用每个时间段占用CPU资源。调度器会在每个时间片结束的时候通过周期中断（tick interrupt）执行一次，调度器根据设置的抢占式还是合作式模式选择哪个任务在下一个时间片会运行。
时间片的大小由configTICK_RATE_HZ这个参数设置。如果configTICK_RATE_HZ设置为10HZ，则时间片的大小为100ms。configTICK_RATE_HZ的值由应用需求决定，通常设为100HZ（时间片大小相应为10ms）。

在上图任务调度的演示中，Kernel表示系统内核即调度程序，Task1和Task2是两个优先级相同的任务。t1到t2是一个时间片，t2到t3是另一个时间片。在每一个时间片快结束的时候，调度程序通过周期中断（tick interrupt）被调用并选择在下一个时间片要执行的任务（红色部分代表调度程序Kernel在运行）。此时因为两个任务的优先级相同，调度程序会让两个任务轮流占用时间片进行运行（蓝色部分代表Task1在运行，绿色部分代表Task2在运行）  

可以把FreeRTOS当成一个时间离散的系统（时间并不是连续的），时间的最小单位是一个节拍（tick），延时函数 vTaskDelayUntil和vTaskDelay的参数需要的是延时的节拍数，不能直接设置延时时间，因此使用 pdMS_TO_TICKS 函数将时间转换为节拍数。通过pdMS_TO_TICKS这个函数可以把时间转换成节拍数（一个节拍代表一个时间片），并且调用这个函数可以保证即使configTICK_RATE_HZ的值不同时时间是一致的。

抢占式时间片调度
内核调度器在每个时间片结束的时候执行一次，选择处于就绪状态的任务中优先级最高的任务置于下一个时间片执行。如果优先级相同的话则交替执行。此时，FreeRTOSConfig.h头文件的设置如下： configUSE_PREEMPTION（允许抢占） 1 configUSE_TIME_SLICING（采用时间片） 1  


抢占式无时间片调度
这种调度方式下，因为没有采取时间片，所以调度器的执行开销会比较小。如果两个任务的优先级相同的话，在抢占式时间片调度下，两个任务会交替运行；在抢占式无时间片调度下，当前运行的任务会一直运行，直到它进入阻塞或者挂起状态，另一个相同优先级的任务才会运行。高优先级的任务会抢占低优先任务。此时，FreeRTOSConfig.h头文件的设置如下：configUSE_PREEMPTION（允许抢占） 1configUSE_TIME_SLICING（采用时间片） 0 


合作式调度

空闲任务(Idle Task)vTaskStartScheduler()函数用来启动调度器。空闲任务是调用器启动后自动创建的一个任务。
FreeRTOS的设计原则是：调度器必须永远有一个可以运行的任务。即使所有用户任务都在等待事件（比如等待一个信号量、一个队列消息或者一个延时到期），系统也必须有事可做。空闲任务就是为了保证始终至少有一个任务处于就绪（Ready）状态而存在的。空闲任务特点:

优先级为0,最低的优先级确保空闲任务不会抢占用户任务。当用户创建的任务都在阻塞或者挂起状态时，空闲任务才执行。
负责清理内核资源，当有任务被删除后，确保空闲任务能运行清理和回收内核资源。

同时，空闲任务可以绑定一个钩子任务（Task Hook），当空闲任务运行的时候钩子任务也会被自动调用。钩子任务里可以添加测量空闲任务运行时间的函数或者把系统放入低功耗模式的函数。空闲任务运行的时间反映出了系统的可用计算资源，可以用于推算CPU的占用率。CPU的占用率过高的话可能会对系统的实时性有影响。  
钩子任务的函数原型是vApplicationIdleHook( void );
]]></content>
  </entry>
</search>
